{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. SFT Mkdocs Layout mkdocs.yml # The configuration file. markdown_docs/ introduction.md # Intro to SFT Package index.md # The documentation homepage. ... # Other markdown pages, images and other files. For full documentation on Makedocs visit mkdocs.org .","title":"Help"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#sft-mkdocs-layout","text":"mkdocs.yml # The configuration file. markdown_docs/ introduction.md # Intro to SFT Package index.md # The documentation homepage. ... # Other markdown pages, images and other files. For full documentation on Makedocs visit mkdocs.org .","title":"SFT Mkdocs Layout"},{"location":"ErrorsInSFT/","text":"Diagnosing Channel Errors in Parallel Systems Diagnosing Channel Errors in Serial Systems","title":"ErrorsInSFT"},{"location":"ErrorsInSFT/#diagnosing-channel-errors-in-parallel-systems","text":"","title":"Diagnosing Channel Errors in Parallel Systems"},{"location":"ErrorsInSFT/#diagnosing-channel-errors-in-serial-systems","text":"","title":"Diagnosing Channel Errors in Serial Systems"},{"location":"LBA/","text":"The Linear Ballistic Accumulator (LBA) Model","title":"The Linear Ballistic Accumulator (LBA) Model"},{"location":"LBA/#the-linear-ballistic-accumulator-lba-model","text":"","title":"The Linear Ballistic Accumulator (LBA) Model"},{"location":"Publications/","text":"Publications Sreekumar, V., Evans, N. J., Garrett, P. M. , Yim, H., Sederberg, P., Dennis, S. (In prep). Using an experience sampling approach to distinguish distance versus location-based processing in memory for when. Planned submission: Psychonomic Bulletin Review . Garrett P. M. , Bennett, M., Howard, Z., Hsieh, Y-.T., Yang, C-.T., Little, D., Eidels, A. (In prep) Cross cultural symbolic wheel of fortune: an investigation into the mental representation of digits for Chinese and English speakers. Planned submission: Frontiers . Howard, Z., Garrett, P. M. , Little, D., Townsend, J., Eidels, A. (In submission) Nice guys check twice: exhaustive processes in systems factorial technology. Psych Review . Yim, H., Garrett, P. M. , Baker, M., Sreekumar, V., Dennis, S. (Under Review). Examining dependencies among different time scales in episodic memory - an experience sampling study. Journal of memory and language . Garrett P. M. , Bennett, M., Howard, Z., Yang, C-.T., Little, D., Eidels, A. (Under review) The cost of errors: confusion analysis and the mental representation of familiar and unfamiliar digits. Acta Psychologica . Garrett, P. M. , Howard, Z., Landy, D., Houpt, J. W., Eidels, A. Comparative estimation systems perform under severely limited workload capacity. Journal of mathematical psychology . Dennis, S., Yim, H., Garrett, P. M. , Sreekumar, V., Stone, B. (2019). A system for collecting and analyzing experience sampling data. Behavioural research methods . Dennis, S., Yim, H., Garrett, P. M. , Sreekumar, V., Stone, B. (2018). Privacy vs open science. Behavioural research methods . Little, D. R., Eidels, A., Houpt, J. W., Garrett P. M. , Griffiths, D. W. (2018). Systems Factorial Technology analysis of mixture models. Journal of mathematical psychology (in submission) . Cooper, P.S., Garrett P.M. , Rennie J.L. Karayanidis F. (2015) Task Uncertainty Can Account for Mixing and Switch Costs in Task-Switching . PLoS ONE . 10(6). Published peer reviewed conference proceedings Dennis, S., Garrett, P.M. , Yim, H., Hamm, J., Osth, A., Sreekumar, V., Stone, B. (2019). Privacy versus Open Science. In Goel, A., Seifert, C., Freksa, C. (Eds.) Proceedings of the 41st Annual Conference of the Cognitive Science Society . Austin, TX: Cognitive Science Society. Yim, H., Garrett, P. M. , Baker, M., Dennis, S. (2018). Examining the independence of scales in episodic memory using experience sampling data. Proceedings of the 40th Annual Conference of the Cognitive Science Society (in submission) . Dennis, S., Yim, H., Sreekumar, V., Evans. N., Garrett, P.M. , Sederberg, P. (2017). A hierarchical Bayesian model of \"memory for when\" based on experience sampling data . Proceedings of the 39th Annual Conference of the Cognitive Science Society . Tillman, G., Howard, Z., Garrett, P.M. , Eidels, A. (2017). The Stroop Effect From a Mixture of Reading Processes: A Fixed-Point Analysis . Proceedings of the 39th Annual Conference of the Cognitive Science Society .","title":"Publications"},{"location":"Publications/#publications","text":"Sreekumar, V., Evans, N. J., Garrett, P. M. , Yim, H., Sederberg, P., Dennis, S. (In prep). Using an experience sampling approach to distinguish distance versus location-based processing in memory for when. Planned submission: Psychonomic Bulletin Review . Garrett P. M. , Bennett, M., Howard, Z., Hsieh, Y-.T., Yang, C-.T., Little, D., Eidels, A. (In prep) Cross cultural symbolic wheel of fortune: an investigation into the mental representation of digits for Chinese and English speakers. Planned submission: Frontiers . Howard, Z., Garrett, P. M. , Little, D., Townsend, J., Eidels, A. (In submission) Nice guys check twice: exhaustive processes in systems factorial technology. Psych Review . Yim, H., Garrett, P. M. , Baker, M., Sreekumar, V., Dennis, S. (Under Review). Examining dependencies among different time scales in episodic memory - an experience sampling study. Journal of memory and language . Garrett P. M. , Bennett, M., Howard, Z., Yang, C-.T., Little, D., Eidels, A. (Under review) The cost of errors: confusion analysis and the mental representation of familiar and unfamiliar digits. Acta Psychologica . Garrett, P. M. , Howard, Z., Landy, D., Houpt, J. W., Eidels, A. Comparative estimation systems perform under severely limited workload capacity. Journal of mathematical psychology . Dennis, S., Yim, H., Garrett, P. M. , Sreekumar, V., Stone, B. (2019). A system for collecting and analyzing experience sampling data. Behavioural research methods . Dennis, S., Yim, H., Garrett, P. M. , Sreekumar, V., Stone, B. (2018). Privacy vs open science. Behavioural research methods . Little, D. R., Eidels, A., Houpt, J. W., Garrett P. M. , Griffiths, D. W. (2018). Systems Factorial Technology analysis of mixture models. Journal of mathematical psychology (in submission) . Cooper, P.S., Garrett P.M. , Rennie J.L. Karayanidis F. (2015) Task Uncertainty Can Account for Mixing and Switch Costs in Task-Switching . PLoS ONE . 10(6).","title":"Publications"},{"location":"Publications/#published-peer-reviewed-conference-proceedings","text":"Dennis, S., Garrett, P.M. , Yim, H., Hamm, J., Osth, A., Sreekumar, V., Stone, B. (2019). Privacy versus Open Science. In Goel, A., Seifert, C., Freksa, C. (Eds.) Proceedings of the 41st Annual Conference of the Cognitive Science Society . Austin, TX: Cognitive Science Society. Yim, H., Garrett, P. M. , Baker, M., Dennis, S. (2018). Examining the independence of scales in episodic memory using experience sampling data. Proceedings of the 40th Annual Conference of the Cognitive Science Society (in submission) . Dennis, S., Yim, H., Sreekumar, V., Evans. N., Garrett, P.M. , Sederberg, P. (2017). A hierarchical Bayesian model of \"memory for when\" based on experience sampling data . Proceedings of the 39th Annual Conference of the Cognitive Science Society . Tillman, G., Howard, Z., Garrett, P.M. , Eidels, A. (2017). The Stroop Effect From a Mixture of Reading Processes: A Fixed-Point Analysis . Proceedings of the 39th Annual Conference of the Cognitive Science Society .","title":"Published peer reviewed conference proceedings"},{"location":"References/","text":"References Townsend, J. (1971). A note on the identifiability of parallel and serial processes ). Perception and psychophysics . 10 (3), 161-163","title":"References"},{"location":"References/#references","text":"Townsend, J. (1971). A note on the identifiability of parallel and serial processes ). Perception and psychophysics . 10 (3), 161-163","title":"References"},{"location":"SFTwithMatlab/","text":"Simulating Response Time Data Linear Balistic Accumulator Discuss the LBA here... Figure 1. Two Channel version of the Linear Ballistic Accumulator (LBA). Evidence for Channel A is gathered in the left hand accumulator, and for Channel B in the right hand accumulator. Starting values for the evidence accumulation process (e.g., K ) are drawn randomly and independently from identical uniform distributions on the interval [0, A ]. The drift rate (e.g., d ) or speed of evidence accumulation is drawn independently for each accumulator from a normal distribution with standard deviation s . Under a self-terminating stopping rule, a response will trigger when the first accumulator reaches the threshold b . Discuss the LBA Paramaters here... % Function to generate response time data using the LBA model % under the assumption of no error drift % Function takes five input variables. % drift = Drift Rate % Threshold = Threshold for response selection % A = Distance to travel from UniDist to Threshold % SD = Within Trial Variability % Ntrials = Number of LBA Trials to return % % E.g., LBA(4, 2.5, 1.5, 1, 100) % Note: t0 = 0 for all time samples RT = f_LBA( drift, Threshold, A, SD, Ntrials ) function [ RT ] = f_LBA( drift, Threshold, A, SD, Ntrials) % Five Input Variables must be defined if nargin ~= 5; error('LBA: Five Variables must be specified'); end % Preallocate Drift Outcome A and B for speed dA = zeros(1, Ntrials); % Establish truncated norms for the drifts to avoid Negative Drift Rates Z = 10^-10; % Make Vector of Drift Rates for each trial while any(dA Z), i = dA Z; x =normrnd(drift,SD,[1,Ntrials]); dA(i)=x(i); end % Sample start points from uniform dist on interval 0-A for between trial % variablility startA = unifrnd(0, A, [1,Ntrials]); % Establish the base RTs for both channels by scaling to the rate of the % Drift. Higher Drift = Faster RT RT = (Threshold-startA) ./ dA; % Check that LBA Start Points begin below Response Threshold if any(RT 0) error('LBA: Drift A or Error Start Point Begins Above Threshold (b). Lower Drift or Increase Thresold'); end % Multiply by 1000 for ms RT = RT * 1000; end Figure 2. Linear Balistic Accumulator (LBA) parameter plots. Columns moving left to right Random Walk Accumulator Paramaters of the Random Walk here... Figure of Paramater change in RW here... Code for the Random Walk Here... Simulating Response Time Channels The following will show how response time data for varying System Architectures can be simulated using the LBA. The code has also been created for the Random Walk accumulator. % Function: Simulate SFT data using a Redundant Target Task with Nine Conditions % % Description: % Factorial Levels resemble the classic Townsend Nozzawa (1977) Dot Detection task % with four levels of Load (Double-Target, Single-Target Left, Single-Target Right, No-Target) % and two levels of Salience (Brightness) nested within target conditions (High Salience H % and Low Salience L). Consequently, Double-Target conditions contain nest a factorial % combination of HH, HL, LH and LL salience levels. % % The Drift H and Drift L within this code reflect the High and Low levels of evidence % accumulation resulting from the Target Salience Manipulation described above. % % Input Variables: % driftH = Target Drift High (also used for Double Absent-Target Drift Rate) % driftL = Target Drift Low % A = Start Point Variablity U[0,A] % SD = Within Trial Variability % SSTfoRand = Boolean variable for Serial Self-Terminating Fix-Order Architectures. % Allows prior selection of which channel will have fix-order attention. % % Example: % E.g., SimulateSFTnine( 'PST', 4, 2, 2.5, 1.5, 1, 1000) % Note: t0 = 0 for all samples % % Terminology: AB - Double Target. A|B - Single Target A or B. Nil - No Target function [ Data, data ] = f_SimulateSFTnineLBA( Model, DriftH, DriftL, Threshold, A, SD, Ntrials, SSTfoRand ) % Variable Error Handling. All variables must be specified if ~exist('Model','var'), error('SimulateSFT: Process Model Must Be Specified i.e., PST, PE, SST, SE, SSTfo, CoActE, CoActST'); end if ~exist('DriftH','var'), error('SimulateSFT: DriftH Rate Must Be Specified and 0'); end if ~exist('DriftL','var'), error('SimulateSFT: DriftL Rate Must Be Specified and 0'); end if ~exist('Threshold','var'), error('SimulateSFT: Threshold Must Be Specified'); end if ~exist('A','var'), error('SimulateSFT: Max Start Point A Must Be Specified. Start Point varies between U[0,A].'); end if ~exist('SD','var'), error('SimulateSFT: SD Must Be Specified'); end if ~exist('Ntrials','var'), error('SimulateSFT: Ntrials Must Be Specified'); end if ~exist('SSTfoRand','var'), SSTfoRand = randsample([0,1],1); end % Drift Salience Matrix for AB, A|B and No Target Conditions ProbMat = {[ DriftH, DriftH, DriftL, DriftL ]; [ DriftH, DriftL, DriftH, DriftL ]}; % Preallocate Channel Comparison Data for AB Condition ChannelData = nan(2, Ntrials, 4); % Preallocate Final RT Data for All Conditions Data = nan(Ntrials, 9); % Make Column Index c = 1; % Calculate Channel Drifts for AB Condition before % application of Architecture and Stopping Rule for Sal = 1:4 ChannelData(1,:,c) = f_LBA(ProbMat{1}(Sal), Threshold, A, SD, Ntrials); ChannelData(2,:,c) = f_LBA(ProbMat{2}(Sal), Threshold, A, SD, Ntrials); c = c + 1; end % A|B Condition RTs can be directly generated without % concern for Architecture or Stopping Rule for Sal = 1:4 Data(:,c) = f_LBA(ProbMat{2}(Sal), Threshold, A, SD, Ntrials); c = c + 1; end % No Target Condition can be assumed as High Salience Data(:,c) = f_LBA(ProbMat{1}(1), Threshold, A, SD, Ntrials); % Function Matrix for the Five Primary Architectures % Parallel ST, Parallel Exh, Serial ST, Serial Exh Coactive funmat = {{'PST', 'PE', 'SST', 'SSTfo', 'SE', 'CoAct'}; % Target Condition Function List {@Arch_ParallelSelfTerminating, ... @Arch_ParallelExhaustive, ... @Arch_SerialSelfTerminating, ... @Arch_FixedOrderSerialSelfTerminating, ... @Arch_SerialExhaustive, ... @Arch_CoactiveLBA}}; % Index which model is being generated index = find(ismember(funmat{1},Model)); % Calculate the RT from the Two AB Channels for cnd = 1:4 if strcmp(Model, 'SSTfo') Data(:,cnd) = funmat{2}{index}( ChannelData(:,:,cnd), 2, SSTfoRand ); elseif strcmp(Model, 'CoAct') Data(:,cnd) = Arch_CoactiveLBA(ProbMat{1}(cnd), ProbMat{2}(cnd), Threshold, A, SD, Ntrials); else Data(:,cnd) = funmat{2}{index}( ChannelData(:,:,cnd) ); end end end Simulating Architectures from Channel RTs Parallel Self Terminating function [ Output ] = Arch_ParallelSelfTerminating( data, NumTargets ) % Function: Simulate Parallel Self Terminating model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Channel Did Not Complete % Default assumes the data is a double-target or double % no-target condition % This is added for ease of use with other Arch_functions if ~exist('NumTargets'), NumTargets = 2; end % Remove All Negative Target Absent Trials Output = data; Output(Output 0)=nan; % Calculate Min Parallel RT over Trial Columns Output = min(Output); % IncorrectChannelError: Initially assumes that all searches would % start on a target item. i.e. All Ones IncorrectChannelError = ones(1,size(data,2)); % IncorrectChannelError: Then checks if Participants made double % channel errors and resulted in a wrong key press i.e., sum(sign)=-2 IncorrectChannelError(sum(sign(data))==-2) = -1; % Parallel Exhaustive Search RTs given Abs Max of data channels ExhaustiveSearch = max(abs(data)); % Replaces Double Negative's with Negative Parallel Exhaustive RTs Output(IncorrectChannelError==-1) = ExhaustiveSearch(IncorrectChannelError==-1) * -1; % Returns Output as a Column Vector Output = Output'; end Parallel Exhaustive function [ Output ] = Arch_ParallelExhaustive( data, NumTargets ) % Function: Simulate Parallel Self Terminating model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Target Absent (non-detected) Channel % Default assumes the data is a double-target or double % no-target condition if ~exist('NumTargets'), NumTargets = 2; end % Index the Min Max Absolute RT in each Channel [~, MinIndex] = nanmin( abs(data) ); [~, MaxIndex] = nanmax( abs(data) ); % Start with the Minimun Absolute RT % while retaining the Channel Sign (+ or -) % This ensures that any Fast Target-Absent responses are % self-terminated early Output = data(sub2ind(size(data), MinIndex, 1:size(data,2))); % Calculate the Max Channel RT MaxRT = data(sub2ind(size(data), MaxIndex, 1:size(data,2))); % Add NaN as the Max RT if one channel did not complete MaxRT(sum(isnan(data))==1)=NaN; % If the channel did not self-terminate with a target-absent response % substitute the channel RT with the Max RT Output(sign(Output)==1) = MaxRT(sign(Output)==1); % Assume all channel responses were correctly made until proven % otherwise Output = abs(Output); % Check for Correct Responses % Start by assuming all responses are incorrect (easier to code) CorrectResponse = -ones(1,size(data,2)); % Then check the channel responses for sign inconsistencies CheckResponse = sum(sign(data)); % Apply Rules for Double-Target and Single-Target Conditions if NumTargets == 2 % If a Double Target Condition... % Correct Response requires a Double-Positive Channel Sign % for an Exhaustive 'Yes' CorrectResponse(CheckResponse==2) = 1; elseif NumTargets == 1 % If a Single Target Condition... % Correct Response is a Single-Positive or Double-Negative % Channel Sign - both result in a Self-Terminating 'No' % NaN channels are assumed to be correct as either they % self-terminate as a correct 'No' or return NaN as a non- % finishing Channel RT CorrectResponse(CheckResponse~=2) = 1; end % Return the Output with Negative RTs for Inccorect Responses and % Positive RTs for Correct Responses Output = Output .* CorrectResponse; % Return Output as Column Vector Output = Output'; end Serial Self-Terminating function [ Output ] = Arch_SerialSelfTerminating( data, NumTargets ) % Author: Paul Garrett 08/03/2017. University of Newcaslte Australia % Function: Simulate Serial Self Terminating model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Channel Did Not Complete % Default assumes the data is a double-target or double % no-target condition % This is added for ease of use with other Arch_functions if ~exist('NumTargets'), NumTargets = 2; end % Rand: Randomly Selects which channel focus is initially dedicated. % Numbers 1 2 refer to the Row in each Trial [Column] of 'data' Rand = randsample([1,2], size(data,2),true); % Output: Generated based upon Random Trial Row/Column Output = data(sub2ind(size(data), Rand, 1:size(data,2))); % Exhaustive Search RT = Sum of Absolute Channel RT ExhaustiveSearch = sum(abs(data)); % Randomly Starting Target Absent Channels will add the RT from % the opposing channel Output(sign(Output)==-1) = ExhaustiveSearch(sign(Output)==-1); % Check for Correct Responses % Start by assuming all responses are correct CorrectResponse = ones(1,size(data,2)); % Then check the channel responses for sign inconsistencies CheckResponse = sum(sign(data)); % Apply Rules for Double-Target and Single-Target Conditions if NumTargets == 2 || NumTargets == 1 % If a Double Target Condition or Single Target Condition... % Correct Response requires a Double-Positive Channel Sign % or a Single-Positive Channel Sign, so only a Double-Negative % would result in an incorrect 'No' response CorrectResponse(CheckResponse==-2) = -1; end % Return the Output with Negative RTs for Inccorect Responses and % Positive RTs for Correct Responses Output = Output .* CorrectResponse; % Return Output as a Column Vector Output = Output'; end Serial Self-Terminating Fixed-Order function [ Output ] = Arch_FixedOrderSerialSelfTerminating( data, NumTargets, SSTfoRand ) % Function: Simulate Serial Self Terminating Fixed Order % model from two streams of data generated using an accumulator model % i.e., LBA, randomwalk % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Target Absent (non-detected) Channel % Default assumes the data is a double-target or double % no-target condition % This is added for ease of use with other Arch_functions if ~exist('NumTargets'), NumTargets = 2; end % Rand is a fixed order variable. Defaults to Channel 1 but if True % changes to fix intial focus on Channel 2 Rand = ones(1, size(data,2)); if SSTfoRand, Rand = Rand * 2; end % Output: Generated based upon Random Trial Row/Column Output = data(sub2ind(size(data), Rand, 1:size(data,2))); % IncorrectChannelError: Initially assumes that all searches would % start on a self-terminating target item. i.e. All Ones IncorrectChannelError = ones(1,size(data,2)); % IncorrectChannelError: Then checks if Participants made double % channel errors and resulted in a wrong key press i.e., sum(sign)=-2 IncorrectChannelError(sum(sign(data))==-2) = -1; % ExhaustiveSearch: RT for an exhaustive search given the Row/Col data. % Multiplies any Double Negative Channel Errors by -1 for easy RT error % analysis ExhaustiveSearch = sum(abs(data)) .* IncorrectChannelError; % Check for Output Errors OutputChannelError = logical(isnan(Output) + (sign(Output) 0)); % Replaces OutputChannelErrors in Output with appropriate Exhaustive % Search RTs - Neg Values are incorrect trials. % NaNs - Processing Never Finished Output(OutputChannelError) = ExhaustiveSearch(OutputChannelError); % Return Output as a Column Vector Output = Output'; end Serial Exhaustive function [ Output ] = Arch_SerialExhaustive( data, NumTargets ) % Function: Simulate Serial Exhaustive model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Channel Did Not Complete % Default assumes the data is a double-target or double % no-target condition if ~exist('NumTargets'), NumTargets = 2; end % Randomly Select which channel attention begins on % 1 2 refer to the Channel (Row) in each Trial (Column) of 'data' Rand = randsample([1,2], size(data,2),true); % Output starts search on Randomly Selected Trial Row/Column Output = data(sub2ind(size(data), Rand, 1:size(data,2))); % Exhaustive Search RT = Sum of Absolute Channel RT ExhaustiveSearch = sum(abs(data)); % Randomly Starting Target Absent Channels will add the RT from % the opposing channel Output(sign(Output)==1) = ExhaustiveSearch(sign(Output)==1); % All Output will be assumed correct until proven otherwise Output = abs(Output); % Check for Correct Responses % Start by assuming all responses are incorrect CorrectResponse = -ones(1,size(data,2)); % Then check the channel responses for sign inconsistencies CheckResponse = sum(sign(data)); % Apply Rules for Double-Target and Single-Target Conditions if NumTargets == 2 % If a Double Target Condition... % Correct Response requires a Double-Positive Channel Sign % for an Exhaustive 'Yes' CorrectResponse(CheckResponse==2) = 1; elseif NumTargets == 1 % If a Single Target Condition... % Correct Response is a Single-Positive or Double-Negative % Channel Sign - both result in a Self-Terminating 'No' % NaN channels are assumed to be correct as either they % self-terminate as a correct 'No' or return NaN as a non- % finishing Channel RT CorrectResponse(CheckResponse~=2) = 1; end % Return the Output with Negative RTs for Inccorect Responses and % Positive RTs for Correct Responses Output = Output .* CorrectResponse; % Returns Output as a Column Vector Output = Output'; end Coactive LBA function [ RT ] = Arch_CoactiveLBA( driftOne, driftTwo, Threshold, A, SD, Ntrials ) % Author: Paul Garrett 08/03/17. University of Newcastle Australia % Function: Simulate LBA accumulation for a single channel with no error % drift. % drift = Drift Rate % Threshold = Threshold for response selection % A = Distance to travel from UniDist to Threshold % SD = Within Trial Variability % Ntrials = Number of LBA Trials to return % E.g., LBA(4, 2.5, 1.5, 1, 100) % Note: t0 = 0 for all time samples if nargin ~= 6; error('LBA: Five Variables must be specified'); end % Preallocate Drift Outcome A and B for speed dA = zeros(1, Ntrials); dB = zeros(1, Ntrials); % Establish truncated norms for the drifts to avoid Negative Drift Rates Z = 10^-10; while any(dA Z), i = dA Z; x =normrnd(driftOne,SD,[1,Ntrials]); dA(i)=x(i); end while any(dB Z), i = dB Z; x =normrnd(driftTwo,SD,[1,Ntrials]); dB(i)=x(i); end % Coactive sum of the drift rates dC = dA + dB; % Sample start points from uniform dist on interval 0-A for across trial % variablility startA = unifrnd(0, A, [1,Ntrials]); % Establish the base RTs for both channels by scaling to the rate of the % Drift. Higher Drift = Faster RT RT = (Threshold-startA) ./ dC; % Check that LBA Start Points begin below Response Threshold if any(RT 0) error('LBA: Drift A or Error Start Point Begins Above Threshold B . Lower Drift or Increase B'); end % Multiply by 1000 for ms RT = RT * 1000; Check = false; if Check figure(); subplot(2,2,1); hist(dA); title('dA') subplot(2,2,2); hist(dB); title('dB') subplot(2,2,3); hist(dC);title('dC (dA+dB)') subplot(2,2,4); hist(RT); title('RT'); suptitle('Coactive Drifts and RT'); end end Coactive Random Walk function [ RT ] = Arch_CoactiveRW( Prob1, Prob2, threshold, Ntrials, Nsamples ) AccumulatorMatrixH = rand(Ntrials, Nsamples); AccumulatorMatrixL = rand(Ntrials, Nsamples); AccumulatorMatrixH = double(AccumulatorMatrixH Prob1); AccumulatorMatrixL = double(AccumulatorMatrixL Prob2); AccumulatorMatrixH(AccumulatorMatrixH==0)=-1; AccumulatorMatrixL(AccumulatorMatrixL==0)=-1; CoactiveMatrix = AccumulatorMatrixH + AccumulatorMatrixL; CoactiveMatrix = cumsum(CoactiveMatrix,2); CoactiveMatrix(:,end+1) = NaN; [r,c] = find(CoactiveMatrix =threshold|CoactiveMatrix =-threshold|isnan(CoactiveMatrix)); index = accumarray(r,c,[],@min); RT = sign(CoactiveMatrix(sub2ind(size(CoactiveMatrix),1:Ntrials, index'))) .* index'; end Assessing Architecture Selective Influence Mean Interaction Contrast (MIC) Survivor Interaction Contrast (SIC) D-Hat Statistic D-Hat vs MIC Significance Test Parallel Exhaustive Parallel Self-Terminating Serial Exhaustive Serial Self-Terminating Assessing Capacity Redundant Target Effect Capacity Coefficient OR Capacity Coefficient AND","title":"SFTwithMatlab"},{"location":"SFTwithMatlab/#simulating-response-time-data","text":"","title":"Simulating Response Time Data"},{"location":"SFTwithMatlab/#linear-balistic-accumulator","text":"Discuss the LBA here... Figure 1. Two Channel version of the Linear Ballistic Accumulator (LBA). Evidence for Channel A is gathered in the left hand accumulator, and for Channel B in the right hand accumulator. Starting values for the evidence accumulation process (e.g., K ) are drawn randomly and independently from identical uniform distributions on the interval [0, A ]. The drift rate (e.g., d ) or speed of evidence accumulation is drawn independently for each accumulator from a normal distribution with standard deviation s . Under a self-terminating stopping rule, a response will trigger when the first accumulator reaches the threshold b . Discuss the LBA Paramaters here... % Function to generate response time data using the LBA model % under the assumption of no error drift % Function takes five input variables. % drift = Drift Rate % Threshold = Threshold for response selection % A = Distance to travel from UniDist to Threshold % SD = Within Trial Variability % Ntrials = Number of LBA Trials to return % % E.g., LBA(4, 2.5, 1.5, 1, 100) % Note: t0 = 0 for all time samples RT = f_LBA( drift, Threshold, A, SD, Ntrials ) function [ RT ] = f_LBA( drift, Threshold, A, SD, Ntrials) % Five Input Variables must be defined if nargin ~= 5; error('LBA: Five Variables must be specified'); end % Preallocate Drift Outcome A and B for speed dA = zeros(1, Ntrials); % Establish truncated norms for the drifts to avoid Negative Drift Rates Z = 10^-10; % Make Vector of Drift Rates for each trial while any(dA Z), i = dA Z; x =normrnd(drift,SD,[1,Ntrials]); dA(i)=x(i); end % Sample start points from uniform dist on interval 0-A for between trial % variablility startA = unifrnd(0, A, [1,Ntrials]); % Establish the base RTs for both channels by scaling to the rate of the % Drift. Higher Drift = Faster RT RT = (Threshold-startA) ./ dA; % Check that LBA Start Points begin below Response Threshold if any(RT 0) error('LBA: Drift A or Error Start Point Begins Above Threshold (b). Lower Drift or Increase Thresold'); end % Multiply by 1000 for ms RT = RT * 1000; end Figure 2. Linear Balistic Accumulator (LBA) parameter plots. Columns moving left to right","title":"Linear Balistic Accumulator"},{"location":"SFTwithMatlab/#random-walk-accumulator","text":"Paramaters of the Random Walk here... Figure of Paramater change in RW here... Code for the Random Walk Here...","title":"Random Walk Accumulator"},{"location":"SFTwithMatlab/#simulating-response-time-channels","text":"The following will show how response time data for varying System Architectures can be simulated using the LBA. The code has also been created for the Random Walk accumulator. % Function: Simulate SFT data using a Redundant Target Task with Nine Conditions % % Description: % Factorial Levels resemble the classic Townsend Nozzawa (1977) Dot Detection task % with four levels of Load (Double-Target, Single-Target Left, Single-Target Right, No-Target) % and two levels of Salience (Brightness) nested within target conditions (High Salience H % and Low Salience L). Consequently, Double-Target conditions contain nest a factorial % combination of HH, HL, LH and LL salience levels. % % The Drift H and Drift L within this code reflect the High and Low levels of evidence % accumulation resulting from the Target Salience Manipulation described above. % % Input Variables: % driftH = Target Drift High (also used for Double Absent-Target Drift Rate) % driftL = Target Drift Low % A = Start Point Variablity U[0,A] % SD = Within Trial Variability % SSTfoRand = Boolean variable for Serial Self-Terminating Fix-Order Architectures. % Allows prior selection of which channel will have fix-order attention. % % Example: % E.g., SimulateSFTnine( 'PST', 4, 2, 2.5, 1.5, 1, 1000) % Note: t0 = 0 for all samples % % Terminology: AB - Double Target. A|B - Single Target A or B. Nil - No Target function [ Data, data ] = f_SimulateSFTnineLBA( Model, DriftH, DriftL, Threshold, A, SD, Ntrials, SSTfoRand ) % Variable Error Handling. All variables must be specified if ~exist('Model','var'), error('SimulateSFT: Process Model Must Be Specified i.e., PST, PE, SST, SE, SSTfo, CoActE, CoActST'); end if ~exist('DriftH','var'), error('SimulateSFT: DriftH Rate Must Be Specified and 0'); end if ~exist('DriftL','var'), error('SimulateSFT: DriftL Rate Must Be Specified and 0'); end if ~exist('Threshold','var'), error('SimulateSFT: Threshold Must Be Specified'); end if ~exist('A','var'), error('SimulateSFT: Max Start Point A Must Be Specified. Start Point varies between U[0,A].'); end if ~exist('SD','var'), error('SimulateSFT: SD Must Be Specified'); end if ~exist('Ntrials','var'), error('SimulateSFT: Ntrials Must Be Specified'); end if ~exist('SSTfoRand','var'), SSTfoRand = randsample([0,1],1); end % Drift Salience Matrix for AB, A|B and No Target Conditions ProbMat = {[ DriftH, DriftH, DriftL, DriftL ]; [ DriftH, DriftL, DriftH, DriftL ]}; % Preallocate Channel Comparison Data for AB Condition ChannelData = nan(2, Ntrials, 4); % Preallocate Final RT Data for All Conditions Data = nan(Ntrials, 9); % Make Column Index c = 1; % Calculate Channel Drifts for AB Condition before % application of Architecture and Stopping Rule for Sal = 1:4 ChannelData(1,:,c) = f_LBA(ProbMat{1}(Sal), Threshold, A, SD, Ntrials); ChannelData(2,:,c) = f_LBA(ProbMat{2}(Sal), Threshold, A, SD, Ntrials); c = c + 1; end % A|B Condition RTs can be directly generated without % concern for Architecture or Stopping Rule for Sal = 1:4 Data(:,c) = f_LBA(ProbMat{2}(Sal), Threshold, A, SD, Ntrials); c = c + 1; end % No Target Condition can be assumed as High Salience Data(:,c) = f_LBA(ProbMat{1}(1), Threshold, A, SD, Ntrials); % Function Matrix for the Five Primary Architectures % Parallel ST, Parallel Exh, Serial ST, Serial Exh Coactive funmat = {{'PST', 'PE', 'SST', 'SSTfo', 'SE', 'CoAct'}; % Target Condition Function List {@Arch_ParallelSelfTerminating, ... @Arch_ParallelExhaustive, ... @Arch_SerialSelfTerminating, ... @Arch_FixedOrderSerialSelfTerminating, ... @Arch_SerialExhaustive, ... @Arch_CoactiveLBA}}; % Index which model is being generated index = find(ismember(funmat{1},Model)); % Calculate the RT from the Two AB Channels for cnd = 1:4 if strcmp(Model, 'SSTfo') Data(:,cnd) = funmat{2}{index}( ChannelData(:,:,cnd), 2, SSTfoRand ); elseif strcmp(Model, 'CoAct') Data(:,cnd) = Arch_CoactiveLBA(ProbMat{1}(cnd), ProbMat{2}(cnd), Threshold, A, SD, Ntrials); else Data(:,cnd) = funmat{2}{index}( ChannelData(:,:,cnd) ); end end end","title":"Simulating Response Time Channels"},{"location":"SFTwithMatlab/#simulating-architectures-from-channel-rts","text":"","title":"Simulating Architectures from Channel RTs"},{"location":"SFTwithMatlab/#parallel-self-terminating","text":"function [ Output ] = Arch_ParallelSelfTerminating( data, NumTargets ) % Function: Simulate Parallel Self Terminating model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Channel Did Not Complete % Default assumes the data is a double-target or double % no-target condition % This is added for ease of use with other Arch_functions if ~exist('NumTargets'), NumTargets = 2; end % Remove All Negative Target Absent Trials Output = data; Output(Output 0)=nan; % Calculate Min Parallel RT over Trial Columns Output = min(Output); % IncorrectChannelError: Initially assumes that all searches would % start on a target item. i.e. All Ones IncorrectChannelError = ones(1,size(data,2)); % IncorrectChannelError: Then checks if Participants made double % channel errors and resulted in a wrong key press i.e., sum(sign)=-2 IncorrectChannelError(sum(sign(data))==-2) = -1; % Parallel Exhaustive Search RTs given Abs Max of data channels ExhaustiveSearch = max(abs(data)); % Replaces Double Negative's with Negative Parallel Exhaustive RTs Output(IncorrectChannelError==-1) = ExhaustiveSearch(IncorrectChannelError==-1) * -1; % Returns Output as a Column Vector Output = Output'; end","title":"Parallel Self Terminating"},{"location":"SFTwithMatlab/#parallel-exhaustive","text":"function [ Output ] = Arch_ParallelExhaustive( data, NumTargets ) % Function: Simulate Parallel Self Terminating model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Target Absent (non-detected) Channel % Default assumes the data is a double-target or double % no-target condition if ~exist('NumTargets'), NumTargets = 2; end % Index the Min Max Absolute RT in each Channel [~, MinIndex] = nanmin( abs(data) ); [~, MaxIndex] = nanmax( abs(data) ); % Start with the Minimun Absolute RT % while retaining the Channel Sign (+ or -) % This ensures that any Fast Target-Absent responses are % self-terminated early Output = data(sub2ind(size(data), MinIndex, 1:size(data,2))); % Calculate the Max Channel RT MaxRT = data(sub2ind(size(data), MaxIndex, 1:size(data,2))); % Add NaN as the Max RT if one channel did not complete MaxRT(sum(isnan(data))==1)=NaN; % If the channel did not self-terminate with a target-absent response % substitute the channel RT with the Max RT Output(sign(Output)==1) = MaxRT(sign(Output)==1); % Assume all channel responses were correctly made until proven % otherwise Output = abs(Output); % Check for Correct Responses % Start by assuming all responses are incorrect (easier to code) CorrectResponse = -ones(1,size(data,2)); % Then check the channel responses for sign inconsistencies CheckResponse = sum(sign(data)); % Apply Rules for Double-Target and Single-Target Conditions if NumTargets == 2 % If a Double Target Condition... % Correct Response requires a Double-Positive Channel Sign % for an Exhaustive 'Yes' CorrectResponse(CheckResponse==2) = 1; elseif NumTargets == 1 % If a Single Target Condition... % Correct Response is a Single-Positive or Double-Negative % Channel Sign - both result in a Self-Terminating 'No' % NaN channels are assumed to be correct as either they % self-terminate as a correct 'No' or return NaN as a non- % finishing Channel RT CorrectResponse(CheckResponse~=2) = 1; end % Return the Output with Negative RTs for Inccorect Responses and % Positive RTs for Correct Responses Output = Output .* CorrectResponse; % Return Output as Column Vector Output = Output'; end","title":"Parallel Exhaustive"},{"location":"SFTwithMatlab/#serial-self-terminating","text":"function [ Output ] = Arch_SerialSelfTerminating( data, NumTargets ) % Author: Paul Garrett 08/03/2017. University of Newcaslte Australia % Function: Simulate Serial Self Terminating model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Channel Did Not Complete % Default assumes the data is a double-target or double % no-target condition % This is added for ease of use with other Arch_functions if ~exist('NumTargets'), NumTargets = 2; end % Rand: Randomly Selects which channel focus is initially dedicated. % Numbers 1 2 refer to the Row in each Trial [Column] of 'data' Rand = randsample([1,2], size(data,2),true); % Output: Generated based upon Random Trial Row/Column Output = data(sub2ind(size(data), Rand, 1:size(data,2))); % Exhaustive Search RT = Sum of Absolute Channel RT ExhaustiveSearch = sum(abs(data)); % Randomly Starting Target Absent Channels will add the RT from % the opposing channel Output(sign(Output)==-1) = ExhaustiveSearch(sign(Output)==-1); % Check for Correct Responses % Start by assuming all responses are correct CorrectResponse = ones(1,size(data,2)); % Then check the channel responses for sign inconsistencies CheckResponse = sum(sign(data)); % Apply Rules for Double-Target and Single-Target Conditions if NumTargets == 2 || NumTargets == 1 % If a Double Target Condition or Single Target Condition... % Correct Response requires a Double-Positive Channel Sign % or a Single-Positive Channel Sign, so only a Double-Negative % would result in an incorrect 'No' response CorrectResponse(CheckResponse==-2) = -1; end % Return the Output with Negative RTs for Inccorect Responses and % Positive RTs for Correct Responses Output = Output .* CorrectResponse; % Return Output as a Column Vector Output = Output'; end","title":"Serial Self-Terminating"},{"location":"SFTwithMatlab/#serial-self-terminating-fixed-order","text":"function [ Output ] = Arch_FixedOrderSerialSelfTerminating( data, NumTargets, SSTfoRand ) % Function: Simulate Serial Self Terminating Fixed Order % model from two streams of data generated using an accumulator model % i.e., LBA, randomwalk % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Target Absent (non-detected) Channel % Default assumes the data is a double-target or double % no-target condition % This is added for ease of use with other Arch_functions if ~exist('NumTargets'), NumTargets = 2; end % Rand is a fixed order variable. Defaults to Channel 1 but if True % changes to fix intial focus on Channel 2 Rand = ones(1, size(data,2)); if SSTfoRand, Rand = Rand * 2; end % Output: Generated based upon Random Trial Row/Column Output = data(sub2ind(size(data), Rand, 1:size(data,2))); % IncorrectChannelError: Initially assumes that all searches would % start on a self-terminating target item. i.e. All Ones IncorrectChannelError = ones(1,size(data,2)); % IncorrectChannelError: Then checks if Participants made double % channel errors and resulted in a wrong key press i.e., sum(sign)=-2 IncorrectChannelError(sum(sign(data))==-2) = -1; % ExhaustiveSearch: RT for an exhaustive search given the Row/Col data. % Multiplies any Double Negative Channel Errors by -1 for easy RT error % analysis ExhaustiveSearch = sum(abs(data)) .* IncorrectChannelError; % Check for Output Errors OutputChannelError = logical(isnan(Output) + (sign(Output) 0)); % Replaces OutputChannelErrors in Output with appropriate Exhaustive % Search RTs - Neg Values are incorrect trials. % NaNs - Processing Never Finished Output(OutputChannelError) = ExhaustiveSearch(OutputChannelError); % Return Output as a Column Vector Output = Output'; end","title":"Serial Self-Terminating Fixed-Order"},{"location":"SFTwithMatlab/#serial-exhaustive","text":"function [ Output ] = Arch_SerialExhaustive( data, NumTargets ) % Function: Simulate Serial Exhaustive model from two streams % of data generated using an accumulator model i.e., LBA % Row 1 of data is the first LBA channel data % Row 2 of data is the second LBA channel data % Negative Values indicate Target Absent trials % NaN Values indicate Channel Did Not Complete % Default assumes the data is a double-target or double % no-target condition if ~exist('NumTargets'), NumTargets = 2; end % Randomly Select which channel attention begins on % 1 2 refer to the Channel (Row) in each Trial (Column) of 'data' Rand = randsample([1,2], size(data,2),true); % Output starts search on Randomly Selected Trial Row/Column Output = data(sub2ind(size(data), Rand, 1:size(data,2))); % Exhaustive Search RT = Sum of Absolute Channel RT ExhaustiveSearch = sum(abs(data)); % Randomly Starting Target Absent Channels will add the RT from % the opposing channel Output(sign(Output)==1) = ExhaustiveSearch(sign(Output)==1); % All Output will be assumed correct until proven otherwise Output = abs(Output); % Check for Correct Responses % Start by assuming all responses are incorrect CorrectResponse = -ones(1,size(data,2)); % Then check the channel responses for sign inconsistencies CheckResponse = sum(sign(data)); % Apply Rules for Double-Target and Single-Target Conditions if NumTargets == 2 % If a Double Target Condition... % Correct Response requires a Double-Positive Channel Sign % for an Exhaustive 'Yes' CorrectResponse(CheckResponse==2) = 1; elseif NumTargets == 1 % If a Single Target Condition... % Correct Response is a Single-Positive or Double-Negative % Channel Sign - both result in a Self-Terminating 'No' % NaN channels are assumed to be correct as either they % self-terminate as a correct 'No' or return NaN as a non- % finishing Channel RT CorrectResponse(CheckResponse~=2) = 1; end % Return the Output with Negative RTs for Inccorect Responses and % Positive RTs for Correct Responses Output = Output .* CorrectResponse; % Returns Output as a Column Vector Output = Output'; end","title":"Serial Exhaustive"},{"location":"SFTwithMatlab/#coactive-lba","text":"function [ RT ] = Arch_CoactiveLBA( driftOne, driftTwo, Threshold, A, SD, Ntrials ) % Author: Paul Garrett 08/03/17. University of Newcastle Australia % Function: Simulate LBA accumulation for a single channel with no error % drift. % drift = Drift Rate % Threshold = Threshold for response selection % A = Distance to travel from UniDist to Threshold % SD = Within Trial Variability % Ntrials = Number of LBA Trials to return % E.g., LBA(4, 2.5, 1.5, 1, 100) % Note: t0 = 0 for all time samples if nargin ~= 6; error('LBA: Five Variables must be specified'); end % Preallocate Drift Outcome A and B for speed dA = zeros(1, Ntrials); dB = zeros(1, Ntrials); % Establish truncated norms for the drifts to avoid Negative Drift Rates Z = 10^-10; while any(dA Z), i = dA Z; x =normrnd(driftOne,SD,[1,Ntrials]); dA(i)=x(i); end while any(dB Z), i = dB Z; x =normrnd(driftTwo,SD,[1,Ntrials]); dB(i)=x(i); end % Coactive sum of the drift rates dC = dA + dB; % Sample start points from uniform dist on interval 0-A for across trial % variablility startA = unifrnd(0, A, [1,Ntrials]); % Establish the base RTs for both channels by scaling to the rate of the % Drift. Higher Drift = Faster RT RT = (Threshold-startA) ./ dC; % Check that LBA Start Points begin below Response Threshold if any(RT 0) error('LBA: Drift A or Error Start Point Begins Above Threshold B . Lower Drift or Increase B'); end % Multiply by 1000 for ms RT = RT * 1000; Check = false; if Check figure(); subplot(2,2,1); hist(dA); title('dA') subplot(2,2,2); hist(dB); title('dB') subplot(2,2,3); hist(dC);title('dC (dA+dB)') subplot(2,2,4); hist(RT); title('RT'); suptitle('Coactive Drifts and RT'); end end","title":"Coactive LBA"},{"location":"SFTwithMatlab/#coactive-random-walk","text":"function [ RT ] = Arch_CoactiveRW( Prob1, Prob2, threshold, Ntrials, Nsamples ) AccumulatorMatrixH = rand(Ntrials, Nsamples); AccumulatorMatrixL = rand(Ntrials, Nsamples); AccumulatorMatrixH = double(AccumulatorMatrixH Prob1); AccumulatorMatrixL = double(AccumulatorMatrixL Prob2); AccumulatorMatrixH(AccumulatorMatrixH==0)=-1; AccumulatorMatrixL(AccumulatorMatrixL==0)=-1; CoactiveMatrix = AccumulatorMatrixH + AccumulatorMatrixL; CoactiveMatrix = cumsum(CoactiveMatrix,2); CoactiveMatrix(:,end+1) = NaN; [r,c] = find(CoactiveMatrix =threshold|CoactiveMatrix =-threshold|isnan(CoactiveMatrix)); index = accumarray(r,c,[],@min); RT = sign(CoactiveMatrix(sub2ind(size(CoactiveMatrix),1:Ntrials, index'))) .* index'; end","title":"Coactive Random Walk"},{"location":"SFTwithMatlab/#assessing-architecture","text":"","title":"Assessing Architecture"},{"location":"SFTwithMatlab/#selective-influence","text":"","title":"Selective Influence"},{"location":"SFTwithMatlab/#mean-interaction-contrast-mic","text":"","title":"Mean Interaction Contrast (MIC)"},{"location":"SFTwithMatlab/#survivor-interaction-contrast-sic","text":"","title":"Survivor Interaction Contrast (SIC)"},{"location":"SFTwithMatlab/#d-hat-statistic","text":"","title":"D-Hat Statistic"},{"location":"SFTwithMatlab/#d-hat-vs-mic-significance-test","text":"","title":"D-Hat vs MIC Significance Test"},{"location":"SFTwithMatlab/#parallel-exhaustive_1","text":"","title":"Parallel Exhaustive"},{"location":"SFTwithMatlab/#parallel-self-terminating_1","text":"","title":"Parallel Self-Terminating"},{"location":"SFTwithMatlab/#serial-exhaustive_1","text":"","title":"Serial Exhaustive"},{"location":"SFTwithMatlab/#serial-self-terminating_1","text":"","title":"Serial Self-Terminating"},{"location":"SFTwithMatlab/#assessing-capacity","text":"","title":"Assessing Capacity"},{"location":"SFTwithMatlab/#redundant-target-effect","text":"","title":"Redundant Target Effect"},{"location":"SFTwithMatlab/#capacity-coefficient-or","text":"","title":"Capacity Coefficient OR"},{"location":"SFTwithMatlab/#capacity-coefficient-and","text":"","title":"Capacity Coefficient AND"},{"location":"SystemsFactorialTechnology/","text":"Introduction On the corner of a busy road, a man waits for the lights to change. Impatient to be home, he looks down at his phone and replies to a message. Glimpsing a green signal and hearing the crossing signal buzz, he steps out onto the road. Our experience of the world relies upon the independent processing and seamless integration of sensory modalities. Tactile, auditory, olfactory and visual information all combine to provide a rich description of the world around us. In the above example, visual cues --- the flash of green --- and auditory cues --- the buzzing signal --- are integrated simultaneously to reach a decisions. This everyday example frames an important question for cognitive scientists: How do we unify two independent sensory streams into a single conscious experience? Cognitive Architecture Since Donders' (1868) subtraction method, cognitive scientists have been using response times (RT) to measure cognitive processes. Donder's assumed that RT could act to measure the additive cognitive processes that underlie behaviour. For example, the cognitive processes of seeing a green light and deciding to walk. By measuring each component in isolation, and subtracting their response-times, Donder's created a measure of cognitive processing. A key assumption of Donder's work was that cognitive processes were additive . A process is additive when the total decision time is equal to the sum of each component processes. Today, additive cognitive processes go by another name, a serial processing system . Under a serial processing system, each component process must terminate before the next may begin. For example, a green walk signal must finish being processed before an auditory buzz may be evaluated. Although serial systems are necessary for many tasks, for example, one must see an object before picking it up; many cognitive process occur simultaneously in a parallel processing system . Egeth (1966) was the first to use RTs to differentiate parallel from serial processing systems. Egeth assumed that if all items within an array were processes simultaneously, (i.e., in parallel), the addition of further items would have no impact on decision-time. As such, a parallel system would predict a flat mean RT slope over increasing array sizes. By contrast, a serial system would predict a steep mean RT slope, increasing with arrays size. As an early adopter of this method, Sternberg (1966) applied these principles to examine whether short-term memory was accessed in serial or in parallel. In his task, participants were presented a list of digits followed by a probe, and were asked to report whether the probed digit was in the memory list. Sternberg found that response-times increased linearly with the length of the memory list. This additivity was used as evidence of a serial processing system, a claim propagated by many influential studies (e.g., Sternberg, 1969; Cohen, 1973; Shiffrin, 1977; Navon, 1977}, and none more influential than Treisman Gelade (1980). In their 1980 Feature Integration Theory of Attention, Treisman and Gelade used mean RT to differentiate parallel and serial visual processing systems. They found RT was invariant across set size when participants searched a display for a singular feature (a dimension of a stimulus, such as a colour or shape), however, increased monotonicity when searching for a conjunction of features (i.e., a coloured triangle; see Figure 1). These findings suggest that a singular feature could be processed irrespective of set size, through a parallel (or over-additive) cognitive processing system. Although compelling, the findings of Treisman and Gelade ignored a key component of a system processing: efficiency. Figure 1. Illustrative example of Mean RT across set size for Feature and Conjunction searchers, as per Treismand and Gelade's (1980) Feature Integration Theory of Attention. Processing efficiency or workload capacity describes the rate at which information may pass through a processing system. Workload capacity is intimately tied to the processing architecture (parallel vs serial) of a system at the mean response-time level, often resulting in the phenomenon of model mimicry. Model mimicry describes how a slow, inefficient parallel system may produce identical mean response-times as a faster serial system. The efficiency of a processing system may be described as either limited, unlimited or super in workload capacity. A limited workload capacity system slows with additional sources of information, for example, processing a green walk sign in the presence of an additional buzzing signal. An unlimited workload capacity system is unaffected by additional sources of information, and a super-capacity system speeds up with additional sources of information. The mean RT predictions of Treisman and Gelade (1980) and colleagues were formed under the assumption of unlimited workload capacity. More recent work has since thrown these assumptions into question (Townsend, 1989; 1071; 1977; 1995; 2004; Eidels et al., 2010; Houpt, 2012; Houpt et al., 2014; Garrett et al., 2018). To address the problem of model mimicry, James Townsend and colleagues (Townsend et al., 1995; 2004; 2011) have developed a theoretically driven framework and suit of mathematical tools, known as Systems Factorial Technology (SFT). Systems Factorial Technology SFT is a theoretical framework, augmented by experimental methodology, that uses response-time distributions to generate unique system-models. By comparing these theoretical models to experimental data, SFT is able to identify system properties without the confound of model mimicry. Specifically, SFT was designed to identify and assess the system properties of architecture, workload capacity, stopping-rule and channel (in)dependence. Architecture describes the time-course at which information channels are combined (parallel vs serial) and workload capacity describes the system efficiency (limited, unlimited and super). Stopping-rule describes how and when processing may terminate. A self-terminating or minimum-time stopping-rule may terminate before all sources of information are fully processed (e.g., you may terminate your search for a cookie at the moment of its detection). An exhaustive or maximum-time stopping-rule must process all sources of information before a decision can be reached (e.g., you must check all the cookie's ingredients for your friend's nut allergy; see Figure 2). Finally, channel (in)dependence describes whether information channels are stochastically separate. Independent channels provide no information to one-another. Dependent channels share information and may act to facilitate or inhibit the decision process (see Eidels et al., 2011). A coactive model describes a special case of parallel processing, where information channels sum together to reach a decision. Notably, a coactive model is unaffected by stopping-rule and predicts super workload capacity. Figure 2. Illustration of Serial, Parallel and Coactive Models. Information feeds forward through each model from input, to information or evidence accumulation, before resulting in a response generation. In the case of the serial model the dotted line indicates a minimum time or 'Self Terminating' response process strategy, where a decision is made after processing completes on the first channel accumulator. SFT is both an analysis tool set and methodological framework. SFT uses distributional analysis tools to directly assess the properties of system architecture, stopping-rule and workload capacity, under the assumption of channel independence. These analysis tools require a specific methodological design, termed the double-factorial redundant-target paradigm (DFP). Figure 3 illustrates a prototypical DFP using a dot-detection task. Here, a target is defined by any source of light, and may appear in the left (channel A) or right (channel B) location. Load, (i.e., the number of information channels), is manipulated by the presence or absence of a target. Within the target conditions exists a second manipulation of target salience, (i.e., target discriminability). A high salience (H) target is easier and faster to respond to than a low salience (L) target. Double-target cells are redundant, as either target would constitute a correct `target present' response. Together, these redundant-cells host four combinations of double-target salience: high-high (HH), high-low (HL), low-high (LH) and low-low (LL). The combined manipulation of load (target presence vs absence) and salience (discriminability high vs low) allows the specially designed analysis tools of SFT to perform independent assessments of system workload and processing architecture. Figure 3. Illustration of a double factorial design necessary for Systems Factorial Technology. The task is a redundant target paradigm. Each sector represents a unique stimulus display. For example, the top left cell represents the Double (redundant) Target, with a High-High target salience manipulation. Figure adapted from Townsend Nozawa (1995). The Capacity Coefficient The first factorial manipulation of load allows for calculation of the capacity coefficient C( t ). The capacity coefficient measures the change in efficiency of the processing system as workload, (i.e., the number of information channels), increases. The capacity coefficient is calculated by comparing the response-time distribution for double-target trials, to the response-time distribution for trials when a target is present in each channel alone --- single-target trials. Formally, the capacity coefficient is expressed as: C( t ) = log(sAB( t )) / [log(sA( t )) + log(sB( t ))] where letters A and B refer to the processing channels when each channel operates alone, A or B, or together AB. S( t ) refers to the survivor function of the channel response-times, t is time, and log is the natural logarithm. The measured change in efficiency between the channel conditions is evaluated against predictions derived from an unlimited capacity independent parallel (UCIP) model. Under the UCIP benchmark model, an unlimited capacity system predicts C( t ) = 1. A super capacity system, one that speeds with additional workload, predicts C( t ) 1. Finally, a limited capacity system predicts C( t ) 1. Mean and Survivor Interaction Contrasts The second factorial manipulation, that of target salience, allows for diagnosis of the system processing architecture through two measures: the mean interaction contrast and the survivor interaction contrast. The mean interaction contrast or MIC, is calculated as a double-difference of mean RT between the four factorial combinations of salience. Formally, the MIC may be written as: MIC = mHH - mHL - mLH + mLL where m denotes a mean response-time, and the letters H and L denote the display salience as combinations of high (H; i.e., bright dot) and low (L; i.e., dull dot) double-target salience-conditions. Thus, HH indicates a trial with two salient targets (two bright dots), HL and LH indicate a trial with one salient and one dull target item, and LL indicates a trial with two dull target items. As high salience targets should be responded to faster than low-salience targets, correct MIC interpretation requires the following ordering: mHH mHL, mLH mLL. Under the assumption of a UCIP model, and correct ordering of the mean RTs, a parallel minimum-time model predicts an over-additive MIC 0, a parallel maximum-time model predicts an under-additive MIC 0 and all serial models predict an additive MIC = 0. These three predictions allow the MIC to easily differentiate between parallel and serial models. To further diagnose stopping-rule, we must turn to the survivor interaction contrast (SIC). The SIC is a contrast measure, similar to the MIC, but calculated from the survivor functions of each double-target salience combination. It is defined as: SIC( t ) = sHH( t ) - sHL( t ) - sLH( t ) + sLL( t ) Different models predict unique SIC( t ) functions, as illustrated in Figure 4. A necessary assumption for valid interpretation of the SICSIC( t ) is the assumption of selective influence and ordering of the composite salience conditions such that sHH( t ) sHL( t ), sLH( t ) sLL( t ). Fortunately, these survivor functions are easily subjected to non-parametric tests. Appropriate application of the SIC( t ) and MIC allows for comprehensive diagnosis of system architecture and stopping rule within the double-target condition. Figure 4. Illustration of the five SIC models predicted by the unique combinations of processing architecture and stopping rule. Note, coactive models are identical under either stopping rule and can be identified by the combination of SIC( t ) and MIC. 18/20/19 Paul To Do: - Processing in the presence of distracting information - Resilience Function - Conflict Contrast Function - Update code on MkDocs Page to that in package - Generate RTdistributions as images for each accumulator model -","title":"Systems Factorial Technology (SFT)"},{"location":"SystemsFactorialTechnology/#introduction","text":"On the corner of a busy road, a man waits for the lights to change. Impatient to be home, he looks down at his phone and replies to a message. Glimpsing a green signal and hearing the crossing signal buzz, he steps out onto the road. Our experience of the world relies upon the independent processing and seamless integration of sensory modalities. Tactile, auditory, olfactory and visual information all combine to provide a rich description of the world around us. In the above example, visual cues --- the flash of green --- and auditory cues --- the buzzing signal --- are integrated simultaneously to reach a decisions. This everyday example frames an important question for cognitive scientists: How do we unify two independent sensory streams into a single conscious experience?","title":"Introduction"},{"location":"SystemsFactorialTechnology/#cognitive-architecture","text":"Since Donders' (1868) subtraction method, cognitive scientists have been using response times (RT) to measure cognitive processes. Donder's assumed that RT could act to measure the additive cognitive processes that underlie behaviour. For example, the cognitive processes of seeing a green light and deciding to walk. By measuring each component in isolation, and subtracting their response-times, Donder's created a measure of cognitive processing. A key assumption of Donder's work was that cognitive processes were additive . A process is additive when the total decision time is equal to the sum of each component processes. Today, additive cognitive processes go by another name, a serial processing system . Under a serial processing system, each component process must terminate before the next may begin. For example, a green walk signal must finish being processed before an auditory buzz may be evaluated. Although serial systems are necessary for many tasks, for example, one must see an object before picking it up; many cognitive process occur simultaneously in a parallel processing system . Egeth (1966) was the first to use RTs to differentiate parallel from serial processing systems. Egeth assumed that if all items within an array were processes simultaneously, (i.e., in parallel), the addition of further items would have no impact on decision-time. As such, a parallel system would predict a flat mean RT slope over increasing array sizes. By contrast, a serial system would predict a steep mean RT slope, increasing with arrays size. As an early adopter of this method, Sternberg (1966) applied these principles to examine whether short-term memory was accessed in serial or in parallel. In his task, participants were presented a list of digits followed by a probe, and were asked to report whether the probed digit was in the memory list. Sternberg found that response-times increased linearly with the length of the memory list. This additivity was used as evidence of a serial processing system, a claim propagated by many influential studies (e.g., Sternberg, 1969; Cohen, 1973; Shiffrin, 1977; Navon, 1977}, and none more influential than Treisman Gelade (1980). In their 1980 Feature Integration Theory of Attention, Treisman and Gelade used mean RT to differentiate parallel and serial visual processing systems. They found RT was invariant across set size when participants searched a display for a singular feature (a dimension of a stimulus, such as a colour or shape), however, increased monotonicity when searching for a conjunction of features (i.e., a coloured triangle; see Figure 1). These findings suggest that a singular feature could be processed irrespective of set size, through a parallel (or over-additive) cognitive processing system. Although compelling, the findings of Treisman and Gelade ignored a key component of a system processing: efficiency. Figure 1. Illustrative example of Mean RT across set size for Feature and Conjunction searchers, as per Treismand and Gelade's (1980) Feature Integration Theory of Attention. Processing efficiency or workload capacity describes the rate at which information may pass through a processing system. Workload capacity is intimately tied to the processing architecture (parallel vs serial) of a system at the mean response-time level, often resulting in the phenomenon of model mimicry. Model mimicry describes how a slow, inefficient parallel system may produce identical mean response-times as a faster serial system. The efficiency of a processing system may be described as either limited, unlimited or super in workload capacity. A limited workload capacity system slows with additional sources of information, for example, processing a green walk sign in the presence of an additional buzzing signal. An unlimited workload capacity system is unaffected by additional sources of information, and a super-capacity system speeds up with additional sources of information. The mean RT predictions of Treisman and Gelade (1980) and colleagues were formed under the assumption of unlimited workload capacity. More recent work has since thrown these assumptions into question (Townsend, 1989; 1071; 1977; 1995; 2004; Eidels et al., 2010; Houpt, 2012; Houpt et al., 2014; Garrett et al., 2018). To address the problem of model mimicry, James Townsend and colleagues (Townsend et al., 1995; 2004; 2011) have developed a theoretically driven framework and suit of mathematical tools, known as Systems Factorial Technology (SFT).","title":"Cognitive Architecture"},{"location":"SystemsFactorialTechnology/#systems-factorial-technology","text":"SFT is a theoretical framework, augmented by experimental methodology, that uses response-time distributions to generate unique system-models. By comparing these theoretical models to experimental data, SFT is able to identify system properties without the confound of model mimicry. Specifically, SFT was designed to identify and assess the system properties of architecture, workload capacity, stopping-rule and channel (in)dependence. Architecture describes the time-course at which information channels are combined (parallel vs serial) and workload capacity describes the system efficiency (limited, unlimited and super). Stopping-rule describes how and when processing may terminate. A self-terminating or minimum-time stopping-rule may terminate before all sources of information are fully processed (e.g., you may terminate your search for a cookie at the moment of its detection). An exhaustive or maximum-time stopping-rule must process all sources of information before a decision can be reached (e.g., you must check all the cookie's ingredients for your friend's nut allergy; see Figure 2). Finally, channel (in)dependence describes whether information channels are stochastically separate. Independent channels provide no information to one-another. Dependent channels share information and may act to facilitate or inhibit the decision process (see Eidels et al., 2011). A coactive model describes a special case of parallel processing, where information channels sum together to reach a decision. Notably, a coactive model is unaffected by stopping-rule and predicts super workload capacity. Figure 2. Illustration of Serial, Parallel and Coactive Models. Information feeds forward through each model from input, to information or evidence accumulation, before resulting in a response generation. In the case of the serial model the dotted line indicates a minimum time or 'Self Terminating' response process strategy, where a decision is made after processing completes on the first channel accumulator. SFT is both an analysis tool set and methodological framework. SFT uses distributional analysis tools to directly assess the properties of system architecture, stopping-rule and workload capacity, under the assumption of channel independence. These analysis tools require a specific methodological design, termed the double-factorial redundant-target paradigm (DFP). Figure 3 illustrates a prototypical DFP using a dot-detection task. Here, a target is defined by any source of light, and may appear in the left (channel A) or right (channel B) location. Load, (i.e., the number of information channels), is manipulated by the presence or absence of a target. Within the target conditions exists a second manipulation of target salience, (i.e., target discriminability). A high salience (H) target is easier and faster to respond to than a low salience (L) target. Double-target cells are redundant, as either target would constitute a correct `target present' response. Together, these redundant-cells host four combinations of double-target salience: high-high (HH), high-low (HL), low-high (LH) and low-low (LL). The combined manipulation of load (target presence vs absence) and salience (discriminability high vs low) allows the specially designed analysis tools of SFT to perform independent assessments of system workload and processing architecture. Figure 3. Illustration of a double factorial design necessary for Systems Factorial Technology. The task is a redundant target paradigm. Each sector represents a unique stimulus display. For example, the top left cell represents the Double (redundant) Target, with a High-High target salience manipulation. Figure adapted from Townsend Nozawa (1995).","title":"Systems Factorial Technology"},{"location":"SystemsFactorialTechnology/#the-capacity-coefficient","text":"The first factorial manipulation of load allows for calculation of the capacity coefficient C( t ). The capacity coefficient measures the change in efficiency of the processing system as workload, (i.e., the number of information channels), increases. The capacity coefficient is calculated by comparing the response-time distribution for double-target trials, to the response-time distribution for trials when a target is present in each channel alone --- single-target trials. Formally, the capacity coefficient is expressed as: C( t ) = log(sAB( t )) / [log(sA( t )) + log(sB( t ))] where letters A and B refer to the processing channels when each channel operates alone, A or B, or together AB. S( t ) refers to the survivor function of the channel response-times, t is time, and log is the natural logarithm. The measured change in efficiency between the channel conditions is evaluated against predictions derived from an unlimited capacity independent parallel (UCIP) model. Under the UCIP benchmark model, an unlimited capacity system predicts C( t ) = 1. A super capacity system, one that speeds with additional workload, predicts C( t ) 1. Finally, a limited capacity system predicts C( t ) 1.","title":"The Capacity Coefficient"},{"location":"SystemsFactorialTechnology/#mean-and-survivor-interaction-contrasts","text":"The second factorial manipulation, that of target salience, allows for diagnosis of the system processing architecture through two measures: the mean interaction contrast and the survivor interaction contrast. The mean interaction contrast or MIC, is calculated as a double-difference of mean RT between the four factorial combinations of salience. Formally, the MIC may be written as: MIC = mHH - mHL - mLH + mLL where m denotes a mean response-time, and the letters H and L denote the display salience as combinations of high (H; i.e., bright dot) and low (L; i.e., dull dot) double-target salience-conditions. Thus, HH indicates a trial with two salient targets (two bright dots), HL and LH indicate a trial with one salient and one dull target item, and LL indicates a trial with two dull target items. As high salience targets should be responded to faster than low-salience targets, correct MIC interpretation requires the following ordering: mHH mHL, mLH mLL. Under the assumption of a UCIP model, and correct ordering of the mean RTs, a parallel minimum-time model predicts an over-additive MIC 0, a parallel maximum-time model predicts an under-additive MIC 0 and all serial models predict an additive MIC = 0. These three predictions allow the MIC to easily differentiate between parallel and serial models. To further diagnose stopping-rule, we must turn to the survivor interaction contrast (SIC). The SIC is a contrast measure, similar to the MIC, but calculated from the survivor functions of each double-target salience combination. It is defined as: SIC( t ) = sHH( t ) - sHL( t ) - sLH( t ) + sLL( t ) Different models predict unique SIC( t ) functions, as illustrated in Figure 4. A necessary assumption for valid interpretation of the SICSIC( t ) is the assumption of selective influence and ordering of the composite salience conditions such that sHH( t ) sHL( t ), sLH( t ) sLL( t ). Fortunately, these survivor functions are easily subjected to non-parametric tests. Appropriate application of the SIC( t ) and MIC allows for comprehensive diagnosis of system architecture and stopping rule within the double-target condition. Figure 4. Illustration of the five SIC models predicted by the unique combinations of processing architecture and stopping rule. Note, coactive models are identical under either stopping rule and can be identified by the combination of SIC( t ) and MIC. 18/20/19 Paul To Do: - Processing in the presence of distracting information - Resilience Function - Conflict Contrast Function - Update code on MkDocs Page to that in package - Generate RTdistributions as images for each accumulator model -","title":"Mean and Survivor Interaction Contrasts"},{"location":"blank/","text":"BLANK","title":"BLANK"},{"location":"blank/#blank","text":"","title":"BLANK"},{"location":"breakingtherules/","text":"Mixtures of Architecture Testing Testing 1 2 3 4 Mixtures of Stopping Rule","title":"Breaking the Rules"},{"location":"breakingtherules/#mixtures-of-architecture","text":"Testing Testing 1 2 3 4","title":"Mixtures of Architecture"},{"location":"breakingtherules/#mixtures-of-stopping-rule","text":"","title":"Mixtures of Stopping Rule"},{"location":"introduction/","text":"Site Purpose This site and the associated GitRepo is the property of Paul M. Garrett, a PhD Candidate at the University of Newcastle, Australia. This document was written to aid other students in the Newcastle Cognition Lab (NewCL) with learning the basic tools used in Systems Factorial Technology (SFT). This document will also address basic accumulator models, such as the Linear Ballistic Accumulator (LBA) model and Random Walk model, and eventually, will extend to understanding multidimensional solutions for complex problems. This document was started in early 2018, however was placed on hiatus due to the time constraints imposed by publishing, completing a timely PhD, and the simultaneous creation of an SFT package for Matlab. The project has since restarted as of October 14 2019. Contacts To get in contact with Paul please email paulgarrett2016@gmail.com or find him on twitter @PaulMGarrett. To see his latest work, check his Google Scholar profile or find him at Research Gate . To contact the Newcastle Cognition Lab, headed by Prof. Scott Brown, reach us through our website or through our twitter @NewcastleCogLab .","title":"General Introduction"},{"location":"introduction/#site-purpose","text":"This site and the associated GitRepo is the property of Paul M. Garrett, a PhD Candidate at the University of Newcastle, Australia. This document was written to aid other students in the Newcastle Cognition Lab (NewCL) with learning the basic tools used in Systems Factorial Technology (SFT). This document will also address basic accumulator models, such as the Linear Ballistic Accumulator (LBA) model and Random Walk model, and eventually, will extend to understanding multidimensional solutions for complex problems. This document was started in early 2018, however was placed on hiatus due to the time constraints imposed by publishing, completing a timely PhD, and the simultaneous creation of an SFT package for Matlab. The project has since restarted as of October 14 2019.","title":"Site Purpose"},{"location":"introduction/#contacts","text":"To get in contact with Paul please email paulgarrett2016@gmail.com or find him on twitter @PaulMGarrett. To see his latest work, check his Google Scholar profile or find him at Research Gate . To contact the Newcastle Cognition Lab, headed by Prof. Scott Brown, reach us through our website or through our twitter @NewcastleCogLab .","title":"Contacts"},{"location":"neuralcorrelatesofcognition/","text":"Parallel and Serial Systems on the Brain","title":"Neuralcorrelatesofcognition"},{"location":"neuralcorrelatesofcognition/#parallel-and-serial-systems-on-the-brain","text":"","title":"Parallel and Serial Systems on the Brain"},{"location":"support/","text":"Contact and Support All code, text and images in the current document have been made by Paul Garrett, a PhD Candidate at the University of Newcastle, Australia. To get in contact with Paul Garrett, please email him at paul.garrett@uon.edu.au or at paulgarrett2016@gmail.com. To cite the SFT with Matlab package, please use the following: Garrett, P. M. Systems Factorial Technology with Matlab. Unpublished manuscript.","title":"Contact and Support"},{"location":"support/#contact-and-support","text":"All code, text and images in the current document have been made by Paul Garrett, a PhD Candidate at the University of Newcastle, Australia. To get in contact with Paul Garrett, please email him at paul.garrett@uon.edu.au or at paulgarrett2016@gmail.com. To cite the SFT with Matlab package, please use the following: Garrett, P. M. Systems Factorial Technology with Matlab. Unpublished manuscript.","title":"Contact and Support"},{"location":"systemsofnumericalcognition/","text":"Exact Report vs. Comparative Judgements Systems of Estimation Systems of Subitizing Mixture Models and Rule Breaking","title":"Systems of Numerical Cognition"},{"location":"systemsofnumericalcognition/#exact-report-vs-comparative-judgements","text":"","title":"Exact Report vs. Comparative Judgements"},{"location":"systemsofnumericalcognition/#systems-of-estimation","text":"","title":"Systems of Estimation"},{"location":"systemsofnumericalcognition/#systems-of-subitizing","text":"","title":"Systems of Subitizing"},{"location":"systemsofnumericalcognition/#mixture-models-and-rule-breaking","text":"","title":"Mixture Models and Rule Breaking"},{"location":"SFTwMatlab/AssessingArchitecture/","text":"asdsak Selective Influence Mean Interaction Contrast (MIC) Survivor Interaction Contrast (SIC) D` Statistic The D statistic is a non-parametric test for assessing the empirical SIC(t)'s departure from zero (Houpt Townsend, 2010). The D statistic is calculated for both the maximum and minimum points of the empirical SIC(t), giving a D+ and D- statistic. The D statistic utilises comparison of the SIC(t) to the maximum and minimum value of a Brownian Bridge, a stochastic process occurring over time with pdf drawn from the conditional probability of a Wiener process with start (t=0) and end points (t=T) anchored at zero and uncertainty greatest in the middle of the distribution. As such, interpretation of the D statistic should be understood as D+ denoting the largest positive value of a Brownian Bridge and D- the magnitude of the smallest value. Given the D statistic's calculation from a Brownian Bridge, a null hypothesis test can be ascertained with the null assuming the maximum SIC(t) positive and negative inflection resulting from the uncertainty of the underlying Brownian Bridge. The D statistic should be interpreted in conjunction with the MIC, as the presence of a D statistic alone is only weak evidence against the null (Houpt Townsend, 2010). D-Hat vs MIC Significance Testing Parallel Exhaustive Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be negative MIC Interaction True MIC Interaction should be significant. Hallmark of Parallel Processing D+ False No significant positive deviation should be observed. See above SIC figure. D- True A significant negative deviation should be observed. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs Parallel Self Terminating Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be positive MIC Interaction True MIC Interaction should be significant. Hallmark of Parallel Processing D+ True A significant positive deviation should be observed. See above SIC figure. D- False No significant negative deviation should be observed. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs Serial Exhaustive Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be equal to zero MIC Interaction False MIC Interaction should not be significant. D+ True A significant positive deviation should be observed. See above SIC figure. D- True A significant negative deviation should be observed. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs Serial Self Terminating Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be equal to zero MIC Interaction False MIC Interaction should not be significant. D+ False No significant positive deviation should be observed. D- False No significant negative deviation should be observed. See above SIC figure. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs","title":"Assessing Architecture"},{"location":"SFTwMatlab/AssessingArchitecture/#selective-influence","text":"","title":"Selective Influence"},{"location":"SFTwMatlab/AssessingArchitecture/#mean-interaction-contrast-mic","text":"","title":"Mean Interaction Contrast (MIC)"},{"location":"SFTwMatlab/AssessingArchitecture/#survivor-interaction-contrast-sic","text":"","title":"Survivor Interaction Contrast (SIC)"},{"location":"SFTwMatlab/AssessingArchitecture/#d-statistic","text":"The D statistic is a non-parametric test for assessing the empirical SIC(t)'s departure from zero (Houpt Townsend, 2010). The D statistic is calculated for both the maximum and minimum points of the empirical SIC(t), giving a D+ and D- statistic. The D statistic utilises comparison of the SIC(t) to the maximum and minimum value of a Brownian Bridge, a stochastic process occurring over time with pdf drawn from the conditional probability of a Wiener process with start (t=0) and end points (t=T) anchored at zero and uncertainty greatest in the middle of the distribution. As such, interpretation of the D statistic should be understood as D+ denoting the largest positive value of a Brownian Bridge and D- the magnitude of the smallest value. Given the D statistic's calculation from a Brownian Bridge, a null hypothesis test can be ascertained with the null assuming the maximum SIC(t) positive and negative inflection resulting from the uncertainty of the underlying Brownian Bridge. The D statistic should be interpreted in conjunction with the MIC, as the presence of a D statistic alone is only weak evidence against the null (Houpt Townsend, 2010).","title":"D` Statistic"},{"location":"SFTwMatlab/AssessingArchitecture/#d-hat-vs-mic-significance-testing","text":"Parallel Exhaustive Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be negative MIC Interaction True MIC Interaction should be significant. Hallmark of Parallel Processing D+ False No significant positive deviation should be observed. See above SIC figure. D- True A significant negative deviation should be observed. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs Parallel Self Terminating Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be positive MIC Interaction True MIC Interaction should be significant. Hallmark of Parallel Processing D+ True A significant positive deviation should be observed. See above SIC figure. D- False No significant negative deviation should be observed. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs Serial Exhaustive Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be equal to zero MIC Interaction False MIC Interaction should not be significant. D+ True A significant positive deviation should be observed. See above SIC figure. D- True A significant negative deviation should be observed. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs Serial Self Terminating Figure Theoretical Expectations Measure Expect Significance Description MIC (mean) MIC should be equal to zero MIC Interaction False MIC Interaction should not be significant. D+ False No significant positive deviation should be observed. D- False No significant negative deviation should be observed. See above SIC figure. Simulated Observations - Dhat vs MIC Simulated Observations - Corresponding SICs","title":"D-Hat vs MIC Significance Testing"},{"location":"SFTwMatlab/AssessingArchitectureTBD/","text":"TBD","title":"AssessingArchitectureTBD"},{"location":"SFTwMatlab/AssessingCapacity/","text":"Assessing Capacity Redundant Target Effect Capacity Coefficient OR Capacity Coefficient AND","title":"AssessingCapacity"},{"location":"SFTwMatlab/AssessingCapacity/#assessing-capacity","text":"","title":"Assessing Capacity"},{"location":"SFTwMatlab/AssessingCapacity/#redundant-target-effect","text":"","title":"Redundant Target Effect"},{"location":"SFTwMatlab/AssessingCapacity/#capacity-coefficient-or","text":"","title":"Capacity Coefficient OR"},{"location":"SFTwMatlab/AssessingCapacity/#capacity-coefficient-and","text":"","title":"Capacity Coefficient AND"},{"location":"SFTwMatlab/AssessingCapacityTBD/","text":"Assessing Capacity TBD","title":"Assessing Capacity"},{"location":"SFTwMatlab/AssessingCapacityTBD/#assessing-capacity","text":"TBD","title":"Assessing Capacity"},{"location":"SFTwMatlab/SimulatingArchitectures/","text":"Simulating Response Time Channels In behavioural research, a subject's response time to the onset of an event or stimulus is assumed to act as an index the completion of a cognitive process. In the framework of a Double-Factorial paradigm, response time acts to index the conclusion of a cognitive process. In some instances, this cognitive process might be the result of top-down processing. For example, the decision to apply a minimum-time or exhaustive search strategy, or to manually shift your focus of attention in a serial search. Other times, this strategic cognitive process involves bottom-up processing with non-conscious For example, in a redundant target task where presence of either target is sufficient to generate a correct 'Yes' response, the strategic cognitive process is to perform a minimum-time search LBA SFT Simulations The following will show how response time data for varying System Architectures can be simulated using the LBA. f_SimulateSFTnineLBA Parameter Type Description Model string String. Takes values 'SST', 'SSTfo', 'SE', 'PST', 'PE' and 'CoAct'. DriftH double Drift rate for the High Salience evidence accumulation channel. DriftL double Drift rate for the Low Salience evidence accumulation channel. Threshold double Response Threshold (b). Higher threshold results in slower response generation. A double Start point variability. Maximum value of the uniform distribution U[0,A] between which the drift Start Point may occur. SD double Standard deviation parameter for the normal distribution from which the drift rate is sampled. Ntrials double Number of trials or Response Times to generate under the given parameter values. SSTfoRand boolean [Optional] True/False value. Fixes channel order as channel A first (True) or channel B first (False) for the Serial Self-Terminating fixed-order architecture. Returns Parameter Type Description Data Matrix An [Ntrials * 9] array of response times in milliseconds. Each column is a unique combination of load and salience, as described by the double-factorial design required for SFT. ChannelData Matrix A [2 * Nrials * 4] 3D array of the channel completion times used when generating the response times returned by Data. Rows indicate Channel A and B respectively, columns are a given trial and the third-dimension is the unique load-salience combination of the double-target condition (see description below for ordering). Description Calculates response times in milliseconds, using the Linear Ballistic Accumulator Model. Assumes t0 is zero for all time samples. Returned Data Array columns match unique combinations of Load and Salience, as described in the Double-Factorial Paradigm necessary for SFT. The 3rd dimension of ChannelData maps to the four Double Target conditions of salience. Column Number Load Salience Abbreviation 1 Double Target High - High AB HH 2 Double Target High - Low AB HL 3 Double Target Low - High AB LH 4 Double Target Low - Low AB LL 5 Single Target High A H 6 Single Target Low A L 7 Single Target High B H 8 Single Target Low B L 9 No Target Equates to High Salience Nil Example Model = 'PST'; % also takes 'SST', 'SSTfo', 'SE', 'PE', 'CoAct' DriftH = 1.6; DriftL = 1.2; Threshold = 1; A = 0; SD = .1; Ntrials = 5; RTData = f_SimulateSFTnineLBA( Model, DriftH, DriftL, Threshold, A, SD, Ntrials) RTData = Columns 1 through 7 613.7729 612.3517 623.1915 856.7324 636.0393 822.2121 704.4101 579.7154 641.5054 549.0849 866.4832 604.1681 819.4840 577.7402 622.6277 711.6705 649.6865 771.3541 574.1917 871.7915 582.3475 657.0529 594.3883 604.1735 829.4403 615.0549 874.6507 580.4431 610.9254 630.9346 615.4763 813.0382 719.0946 794.3802 593.0726 Columns 8 through 9 851.3901 631.7892 938.7937 642.8301 838.4938 635.0806 924.1590 643.8739 728.9819 601.4685 % Returns optional output argument for Channel Response Times [RTData, ChannelData] = f_SimulateSFTnineLBA( Model, DriftH, DriftL, Threshold, A, SD, Ntrials); ChannelData ChannelData(:,:,1) = 621.0754 695.5822 711.1573 657.0529 610.9254 613.7729 579.7154 622.6277 662.7162 671.8474 ChannelData(:,:,2) = 612.3517 641.5054 711.6705 594.3883 630.9346 984.0588 810.8489 743.0004 752.8701 857.2904 ChannelData(:,:,3) = 942.1947 796.9356 818.8018 949.7159 788.6477 623.1915 549.0849 649.6865 604.1735 615.4763 ChannelData(:,:,4) = 1.0e+03 * 0.8567 0.8932 0.7714 0.9584 0.8130 0.9304 0.8665 1.0846 0.8294 0.9580 Random Walk SFT Simulations The following will show how response time data for varying System Architectures can be simulated using the Random Walk Model. f_SimulateSFTnineRW Parameter Type Description Model string String. Takes values 'SST', 'SSTfo', 'SE', 'PST', 'PE' and 'CoAct'. ProbH double Step Probability for the high salience condition. ProbL double Step Probability for the low salience condition. Threshold double Response Threshold (b). Higher threshold results in slower response generation. Ntrials double Number of trials or Response Times to generate under the given parameter values. Nsamples double Number of step samples to be taken on each trial. Failure to reach a response threshold by Nsamples returns a no response NaN. Returns Parameter Type Description Data Array 2D matrix with dimensions [ Ntrials * 9 ]. The nine columns constitute unique combinations of Load and Salience conditions within the Double Factorial Paradigm. See description below. Negative values typically indicate an incorrect response (the opposing decision bound was met), NaN values indicate no-response and positive values indicate a correct response. ChannelData Array A [2 * Nrials * 4] 3D array of the channel completion times used when generating the response times returned by Data. Rows indicate Channel A and B respectively, columns are a given trial and the third-dimension is the unique load-salience combination of the double-target condition (see description below for ordering). Description Calculates response times in milliseconds for the nine unique conditions that constitute the classical SFT double factorial paradigm, using the Linear Ballistic Accumulator Model. Assumes t0 is zero for all time samples. Returned Data Array columns match unique combinations of Load and Salience, as described in the Double-Factorial Paradigm necessary for SFT. Column Number Load Salience Abbreviation 1 Double Target High - High AB HH 2 Double Target High - Low AB HL 3 Double Target Low - High AB LH 4 Double Target Low - Low AB LL 5 Single Target High A H 6 Single Target Low A L 7 Single Target High B H 8 Single Target Low B L 9 No Target Equates to High Salience Nil Example % Set Model and RW Parameter Values ProbH = .7; ProbL = .6; Threshold = 20; Ntrials = 5; Nsamples = 250; % Call Function RTData = f_SimulateSFTnineRW( Model, ProbH, ProbL, Threshold, Ntrials, Nsamples ) RTData = 56 76 32 64 44 112 56 56 38 34 50 40 74 36 76 62 74 64 42 38 42 60 32 208 50 72 26 34 32 36 40 30 76 28 98 72 38 34 42 76 36 112 48 112 44 % Also takes optional output arguments to return the Channel Response Times [RTData, ChannelData] = f_SimulateSFTnineRW( Model, ProbH, ProbL, Threshold, Ntrials, Nsamples ); ChannelData ChannelData(:,:,1) = 56 38 42 40 46 58 34 48 34 38 ChannelData(:,:,2) = 76 50 38 32 34 108 226 88 46 74 ChannelData(:,:,3) = 32 48 50 118 64 52 40 42 36 42 ChannelData(:,:,4) = 64 74 94 88 98 70 90 60 40 76 Simulated System Architectures Parallel Self Terminating timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'PST', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Parallel Self Terminating SIC', true ); Parallel Exhaustive timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'PE', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Parallel Exhaustive', true ); Serial Self Terminating timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'SST', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Serial Self Terminating', true ); Fixed Order Serial Self-Terminating timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'SSTfo', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Fixed Order Serial Self Terminating', true ); Serial Exhaustive timebins = 1:10:3000; RTData = f_SimulateSFTnineLBA( 'SE', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Serial Exhaustive', true ); Parallel Coactive timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'CoAct', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Coactive', true );","title":"Simulating Architectures"},{"location":"SFTwMatlab/SimulatingArchitectures/#simulating-response-time-channels","text":"In behavioural research, a subject's response time to the onset of an event or stimulus is assumed to act as an index the completion of a cognitive process. In the framework of a Double-Factorial paradigm, response time acts to index the conclusion of a cognitive process. In some instances, this cognitive process might be the result of top-down processing. For example, the decision to apply a minimum-time or exhaustive search strategy, or to manually shift your focus of attention in a serial search. Other times, this strategic cognitive process involves bottom-up processing with non-conscious For example, in a redundant target task where presence of either target is sufficient to generate a correct 'Yes' response, the strategic cognitive process is to perform a minimum-time search","title":"Simulating Response Time Channels"},{"location":"SFTwMatlab/SimulatingArchitectures/#lba-sft-simulations","text":"The following will show how response time data for varying System Architectures can be simulated using the LBA. f_SimulateSFTnineLBA Parameter Type Description Model string String. Takes values 'SST', 'SSTfo', 'SE', 'PST', 'PE' and 'CoAct'. DriftH double Drift rate for the High Salience evidence accumulation channel. DriftL double Drift rate for the Low Salience evidence accumulation channel. Threshold double Response Threshold (b). Higher threshold results in slower response generation. A double Start point variability. Maximum value of the uniform distribution U[0,A] between which the drift Start Point may occur. SD double Standard deviation parameter for the normal distribution from which the drift rate is sampled. Ntrials double Number of trials or Response Times to generate under the given parameter values. SSTfoRand boolean [Optional] True/False value. Fixes channel order as channel A first (True) or channel B first (False) for the Serial Self-Terminating fixed-order architecture. Returns Parameter Type Description Data Matrix An [Ntrials * 9] array of response times in milliseconds. Each column is a unique combination of load and salience, as described by the double-factorial design required for SFT. ChannelData Matrix A [2 * Nrials * 4] 3D array of the channel completion times used when generating the response times returned by Data. Rows indicate Channel A and B respectively, columns are a given trial and the third-dimension is the unique load-salience combination of the double-target condition (see description below for ordering). Description Calculates response times in milliseconds, using the Linear Ballistic Accumulator Model. Assumes t0 is zero for all time samples. Returned Data Array columns match unique combinations of Load and Salience, as described in the Double-Factorial Paradigm necessary for SFT. The 3rd dimension of ChannelData maps to the four Double Target conditions of salience. Column Number Load Salience Abbreviation 1 Double Target High - High AB HH 2 Double Target High - Low AB HL 3 Double Target Low - High AB LH 4 Double Target Low - Low AB LL 5 Single Target High A H 6 Single Target Low A L 7 Single Target High B H 8 Single Target Low B L 9 No Target Equates to High Salience Nil Example Model = 'PST'; % also takes 'SST', 'SSTfo', 'SE', 'PE', 'CoAct' DriftH = 1.6; DriftL = 1.2; Threshold = 1; A = 0; SD = .1; Ntrials = 5; RTData = f_SimulateSFTnineLBA( Model, DriftH, DriftL, Threshold, A, SD, Ntrials) RTData = Columns 1 through 7 613.7729 612.3517 623.1915 856.7324 636.0393 822.2121 704.4101 579.7154 641.5054 549.0849 866.4832 604.1681 819.4840 577.7402 622.6277 711.6705 649.6865 771.3541 574.1917 871.7915 582.3475 657.0529 594.3883 604.1735 829.4403 615.0549 874.6507 580.4431 610.9254 630.9346 615.4763 813.0382 719.0946 794.3802 593.0726 Columns 8 through 9 851.3901 631.7892 938.7937 642.8301 838.4938 635.0806 924.1590 643.8739 728.9819 601.4685 % Returns optional output argument for Channel Response Times [RTData, ChannelData] = f_SimulateSFTnineLBA( Model, DriftH, DriftL, Threshold, A, SD, Ntrials); ChannelData ChannelData(:,:,1) = 621.0754 695.5822 711.1573 657.0529 610.9254 613.7729 579.7154 622.6277 662.7162 671.8474 ChannelData(:,:,2) = 612.3517 641.5054 711.6705 594.3883 630.9346 984.0588 810.8489 743.0004 752.8701 857.2904 ChannelData(:,:,3) = 942.1947 796.9356 818.8018 949.7159 788.6477 623.1915 549.0849 649.6865 604.1735 615.4763 ChannelData(:,:,4) = 1.0e+03 * 0.8567 0.8932 0.7714 0.9584 0.8130 0.9304 0.8665 1.0846 0.8294 0.9580","title":"LBA SFT Simulations"},{"location":"SFTwMatlab/SimulatingArchitectures/#random-walk-sft-simulations","text":"The following will show how response time data for varying System Architectures can be simulated using the Random Walk Model. f_SimulateSFTnineRW Parameter Type Description Model string String. Takes values 'SST', 'SSTfo', 'SE', 'PST', 'PE' and 'CoAct'. ProbH double Step Probability for the high salience condition. ProbL double Step Probability for the low salience condition. Threshold double Response Threshold (b). Higher threshold results in slower response generation. Ntrials double Number of trials or Response Times to generate under the given parameter values. Nsamples double Number of step samples to be taken on each trial. Failure to reach a response threshold by Nsamples returns a no response NaN. Returns Parameter Type Description Data Array 2D matrix with dimensions [ Ntrials * 9 ]. The nine columns constitute unique combinations of Load and Salience conditions within the Double Factorial Paradigm. See description below. Negative values typically indicate an incorrect response (the opposing decision bound was met), NaN values indicate no-response and positive values indicate a correct response. ChannelData Array A [2 * Nrials * 4] 3D array of the channel completion times used when generating the response times returned by Data. Rows indicate Channel A and B respectively, columns are a given trial and the third-dimension is the unique load-salience combination of the double-target condition (see description below for ordering). Description Calculates response times in milliseconds for the nine unique conditions that constitute the classical SFT double factorial paradigm, using the Linear Ballistic Accumulator Model. Assumes t0 is zero for all time samples. Returned Data Array columns match unique combinations of Load and Salience, as described in the Double-Factorial Paradigm necessary for SFT. Column Number Load Salience Abbreviation 1 Double Target High - High AB HH 2 Double Target High - Low AB HL 3 Double Target Low - High AB LH 4 Double Target Low - Low AB LL 5 Single Target High A H 6 Single Target Low A L 7 Single Target High B H 8 Single Target Low B L 9 No Target Equates to High Salience Nil Example % Set Model and RW Parameter Values ProbH = .7; ProbL = .6; Threshold = 20; Ntrials = 5; Nsamples = 250; % Call Function RTData = f_SimulateSFTnineRW( Model, ProbH, ProbL, Threshold, Ntrials, Nsamples ) RTData = 56 76 32 64 44 112 56 56 38 34 50 40 74 36 76 62 74 64 42 38 42 60 32 208 50 72 26 34 32 36 40 30 76 28 98 72 38 34 42 76 36 112 48 112 44 % Also takes optional output arguments to return the Channel Response Times [RTData, ChannelData] = f_SimulateSFTnineRW( Model, ProbH, ProbL, Threshold, Ntrials, Nsamples ); ChannelData ChannelData(:,:,1) = 56 38 42 40 46 58 34 48 34 38 ChannelData(:,:,2) = 76 50 38 32 34 108 226 88 46 74 ChannelData(:,:,3) = 32 48 50 118 64 52 40 42 36 42 ChannelData(:,:,4) = 64 74 94 88 98 70 90 60 40 76","title":"Random Walk SFT Simulations"},{"location":"SFTwMatlab/SimulatingArchitectures/#simulated-system-architectures","text":"Parallel Self Terminating timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'PST', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Parallel Self Terminating SIC', true ); Parallel Exhaustive timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'PE', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Parallel Exhaustive', true ); Serial Self Terminating timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'SST', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Serial Self Terminating', true ); Fixed Order Serial Self-Terminating timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'SSTfo', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Fixed Order Serial Self Terminating', true ); Serial Exhaustive timebins = 1:10:3000; RTData = f_SimulateSFTnineLBA( 'SE', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Serial Exhaustive', true ); Parallel Coactive timebins = 1:10:1500; RTData = f_SimulateSFTnineLBA( 'CoAct', 1.6, 1.2, 1, 0, .2, 100000); [SIC, bootstrap, dhat] = f_SIC(RTData(:,1:4), timebins, true, true ); f_PlotSIC( SIC, timebins, bootstrap, dhat, 'Coactive', true );","title":"Simulated System Architectures"},{"location":"SFTwMatlab/SimulatingData/","text":"Simulating Response Time Data The following section will discuss several accumulator models that may be used to generate the response-time predictions humans completing a range of tasks. The models we will cover will include the Linear Ballistic Accumulator Model, the Random Walk model, the Poisson Model and the Diffusion Model. Each of these models have unique benefits relative to one-another. Importantly, each model incorporates theoretically driven parameters not only predict human decision times, but help explain the cognitive processes that underpin these behaviours. Understanding how these models work is difficult for new students. The SFT with Matlab package is designed to make this process easier. It provides easy-to-understand functions that let you generate data using these methods, and along the way, appreciate how these models work. Paul up to here 14/10/19, old content continues from here... Linear Balistic Accumulator Discuss the LBA here... Figure 1. Two Channel version of the Linear Ballistic Accumulator (LBA). Evidence for Channel A is gathered in the left hand accumulator, and for Channel B in the right hand accumulator. Starting values for the evidence accumulation process (e.g., K ) are drawn randomly and independently from identical uniform distributions on the interval [0, A ]. The drift rate (e.g., d ) or speed of evidence accumulation is drawn independently for each accumulator from a normal distribution with standard deviation s . Under a self-terminating stopping rule, a response will trigger when the first accumulator reaches the threshold b . Discuss the LBA Paramaters here... Function f_LBA Parameter Type Description drift double Drift Rate (d) for the channel accumulator. Higher drift rates result in faster evidence accumulation Threshold double Response Threshold (b). Higher threshold results in slower response generation. A double Start point variability. Maximum value of the uniform distribution U[0,A] between which the drift Start Point may occur SD double Standard deviation parameter for the normal distribution from which the drift rate is sampled. Ntrials double Number of trials or Response Times to generate under the given parameter values. Returns Returns a vector of response time values 1*Ntrials long. Description Calculates response times in milliseconds, using the Linear Ballistic Accumulator Model. Assumes t0 is zero for all time samples. Example % Set LBA Parameters drift = 1.2; Threshold = 1; A = .50; SD = .1; Ntrials = 10; % Call f_LBA Function RT = f_LBA( drift, Threshold, A, SD, Ntrials ) RT = Columns 1 through 7 510.5766 911.8206 677.4572 716.7259 761.8242 451.3118 512.7615 Columns 8 through 10 719.3998 426.9517 876.4842 Figure 2. Probability density functions for response times generated using the f_LBA function given one-million trials. Columns moving left to right indicate increase parameter values for drift rate (d), threshold (b), start point variability (A), and the standard deviation of the drift (SD). Parameter values increase incrementally as indicated by the text of each subplot. The first row illustrates fixed parameter values for all columns. All response times are generated with the assumption of no error drift rate and a t0 = 0. Random Walk Accumulator Discuss background of Random Walk here Function f_RandomWalk Parameter Type Description Probability double Probability of each RW step. Probabilities above 0.5 will on average move towards the positive response threshold, while probabilities below 0.5 will on average step towards the negative response threshold. Threshold double Response Threshold (b). Higher threshold results in slower response generation. Ntrials double Number of Response time trials to generate Nsamples double Number of Steps sampled for each trial. If Nsamples is less than required to reach a response threshold, a NaN value will be returned indicating no response was made. Returns Returns a vector of response time values Ntrials long. Description Calculates response times in milliseconds, using the Random Walk Model. Example % Set RW Parameters StepProb = .65; Threshold = 250; Ntrials = 10; Nsamples = 1500; % Call f_RandomWalk Function RT = f_RandomWalk( StepProb, Threshold, Ntrials, Nsamples ) RT = 982 860 840 850 972 968 862 770 896 740 Figure 3. Probability density functions for response times generated using the f_RandomWalk function. Columns moving left to right indicate increase parameter values for step probability (p), threshold (b), number of trials (N), and the number of steps sampled for each trial RT (S) . Parameter values increase incrementally as indicated by the text of each subplot, except for Nsamples which decreases. The first row illustrates fixed parameter values for all columns.","title":"Simulating Data"},{"location":"SFTwMatlab/SimulatingData/#simulating-response-time-data","text":"The following section will discuss several accumulator models that may be used to generate the response-time predictions humans completing a range of tasks. The models we will cover will include the Linear Ballistic Accumulator Model, the Random Walk model, the Poisson Model and the Diffusion Model. Each of these models have unique benefits relative to one-another. Importantly, each model incorporates theoretically driven parameters not only predict human decision times, but help explain the cognitive processes that underpin these behaviours. Understanding how these models work is difficult for new students. The SFT with Matlab package is designed to make this process easier. It provides easy-to-understand functions that let you generate data using these methods, and along the way, appreciate how these models work. Paul up to here 14/10/19, old content continues from here...","title":"Simulating Response Time Data"},{"location":"SFTwMatlab/SimulatingData/#linear-balistic-accumulator","text":"Discuss the LBA here... Figure 1. Two Channel version of the Linear Ballistic Accumulator (LBA). Evidence for Channel A is gathered in the left hand accumulator, and for Channel B in the right hand accumulator. Starting values for the evidence accumulation process (e.g., K ) are drawn randomly and independently from identical uniform distributions on the interval [0, A ]. The drift rate (e.g., d ) or speed of evidence accumulation is drawn independently for each accumulator from a normal distribution with standard deviation s . Under a self-terminating stopping rule, a response will trigger when the first accumulator reaches the threshold b . Discuss the LBA Paramaters here... Function f_LBA Parameter Type Description drift double Drift Rate (d) for the channel accumulator. Higher drift rates result in faster evidence accumulation Threshold double Response Threshold (b). Higher threshold results in slower response generation. A double Start point variability. Maximum value of the uniform distribution U[0,A] between which the drift Start Point may occur SD double Standard deviation parameter for the normal distribution from which the drift rate is sampled. Ntrials double Number of trials or Response Times to generate under the given parameter values. Returns Returns a vector of response time values 1*Ntrials long. Description Calculates response times in milliseconds, using the Linear Ballistic Accumulator Model. Assumes t0 is zero for all time samples. Example % Set LBA Parameters drift = 1.2; Threshold = 1; A = .50; SD = .1; Ntrials = 10; % Call f_LBA Function RT = f_LBA( drift, Threshold, A, SD, Ntrials ) RT = Columns 1 through 7 510.5766 911.8206 677.4572 716.7259 761.8242 451.3118 512.7615 Columns 8 through 10 719.3998 426.9517 876.4842 Figure 2. Probability density functions for response times generated using the f_LBA function given one-million trials. Columns moving left to right indicate increase parameter values for drift rate (d), threshold (b), start point variability (A), and the standard deviation of the drift (SD). Parameter values increase incrementally as indicated by the text of each subplot. The first row illustrates fixed parameter values for all columns. All response times are generated with the assumption of no error drift rate and a t0 = 0.","title":"Linear Balistic Accumulator"},{"location":"SFTwMatlab/SimulatingData/#random-walk-accumulator","text":"Discuss background of Random Walk here Function f_RandomWalk Parameter Type Description Probability double Probability of each RW step. Probabilities above 0.5 will on average move towards the positive response threshold, while probabilities below 0.5 will on average step towards the negative response threshold. Threshold double Response Threshold (b). Higher threshold results in slower response generation. Ntrials double Number of Response time trials to generate Nsamples double Number of Steps sampled for each trial. If Nsamples is less than required to reach a response threshold, a NaN value will be returned indicating no response was made. Returns Returns a vector of response time values Ntrials long. Description Calculates response times in milliseconds, using the Random Walk Model. Example % Set RW Parameters StepProb = .65; Threshold = 250; Ntrials = 10; Nsamples = 1500; % Call f_RandomWalk Function RT = f_RandomWalk( StepProb, Threshold, Ntrials, Nsamples ) RT = 982 860 840 850 972 968 862 770 896 740 Figure 3. Probability density functions for response times generated using the f_RandomWalk function. Columns moving left to right indicate increase parameter values for step probability (p), threshold (b), number of trials (N), and the number of steps sampled for each trial RT (S) . Parameter values increase incrementally as indicated by the text of each subplot, except for Nsamples which decreases. The first row illustrates fixed parameter values for all columns.","title":"Random Walk Accumulator"}]}